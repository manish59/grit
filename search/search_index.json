{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"grit-genomics","text":"<p>Python bindings for GRIT (Genomic Range Interval Toolkit).</p> <p> </p> <p>grit-genomics provides Python bindings for GRIT, a genomic interval toolkit written in Rust. The package is imported as <code>pygrit</code>.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>13 Commands: intersect, merge, subtract, closest, window, coverage, sort, slop, complement, genomecov, jaccard, multiinter, generate</li> <li>File Operations: Process BED files with streaming algorithms</li> <li>In-Memory Operations: Work with intervals programmatically</li> <li>NumPy Integration: Convert between intervals and NumPy arrays</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import pygrit\n\n# Find overlapping intervals between two BED files\nresults = pygrit.intersect(\"genes.bed\", \"peaks.bed\")\n\n# Merge overlapping intervals\nmerged = pygrit.merge(\"regions.bed\", distance=100)\n\n# Sort a BED file\npygrit.sort(\"unsorted.bed\", output=\"sorted.bed\")\n\n# Work with individual intervals\niv = pygrit.Interval(\"chr1\", 1000, 2000)\nprint(f\"Length: {len(iv)} bp\")  # Length: 1000 bp\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install grit-genomics\n</code></pre> <pre><code>import pygrit\nprint(pygrit.__version__)\n</code></pre> <p>See the Installation Guide for more options.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started: Installation and first steps</li> <li>User Guide: Tutorials and guides</li> <li>API Reference: Complete API documentation</li> <li>Examples: Usage examples</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python &gt;= 3.9</li> <li>NumPy &gt;= 1.20</li> <li>Most functions require sorted BED input files</li> </ul>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<ul> <li>GRIT - The underlying Rust implementation</li> <li>bedtools by Aaron Quinlan - The original genomic interval toolkit that inspired this project</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License. See LICENSE for details.</p>"},{"location":"api/","title":"API Reference","text":"<p>Complete API documentation for pygrit.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>pygrit provides two main ways to work with genomic intervals:</p>"},{"location":"api/#core-types","title":"Core Types","text":"<ul> <li><code>Interval</code>: A single genomic interval with chromosome, start, and end</li> <li><code>IntervalSet</code>: A collection of intervals with bulk operations</li> </ul>"},{"location":"api/#file-based-operations","title":"File-Based Operations","text":"<p>Functions that process BED files:</p> <ul> <li><code>intersect</code>: Find overlapping intervals</li> <li><code>merge</code>: Merge overlapping intervals</li> <li><code>subtract</code>: Subtract intervals</li> <li><code>coverage</code>: Calculate coverage</li> <li><code>closest</code>: Find closest intervals</li> <li><code>window</code>: Find intervals within a window</li> <li><code>sort</code>: Sort BED files</li> <li><code>slop</code>: Extend interval boundaries</li> <li><code>complement</code>: Find gaps between intervals</li> <li><code>genomecov</code>: Genome-wide coverage</li> <li><code>jaccard</code>: Jaccard similarity</li> <li><code>multiinter</code>: Multi-file intersection</li> <li><code>generate</code>: Generate synthetic data</li> </ul>"},{"location":"api/#io-functions","title":"I/O Functions","text":"<ul> <li><code>read_bed</code>: Read intervals from a BED file</li> <li><code>parse_bed</code>: Parse intervals from a string</li> <li><code>from_numpy</code>: Create intervals from NumPy array</li> </ul>"},{"location":"api/#quick-reference","title":"Quick Reference","text":""},{"location":"api/#coordinate-system","title":"Coordinate System","text":"<p>pygrit uses 0-based, half-open coordinates (BED format):</p> <ul> <li>Start: 0-based, inclusive</li> <li>End: 0-based, exclusive</li> <li>Length: <code>end - start</code></li> </ul> <pre><code># An interval covering bases 100-199 (100 bases)\niv = pygrit.Interval(\"chr1\", 100, 200)\nlen(iv)  # 100\n</code></pre>"},{"location":"api/#import","title":"Import","text":"<pre><code>import pygrit\n\n# Core types\npygrit.Interval\npygrit.IntervalSet\n\n# File operations\npygrit.intersect\npygrit.merge\npygrit.subtract\npygrit.coverage\npygrit.closest\npygrit.window\npygrit.sort\npygrit.slop\npygrit.complement\npygrit.genomecov\npygrit.jaccard\npygrit.multiinter\npygrit.generate\n\n# I/O\npygrit.read_bed\npygrit.parse_bed\npygrit.from_numpy\n\n# Metadata\npygrit.__version__\n</code></pre>"},{"location":"api/#input-requirements","title":"Input Requirements","text":"<p>Most file-based functions require sorted BED files (sorted by chromosome, then by start position).</p> <p>Sort files first:</p> <pre><code>pygrit.sort(\"unsorted.bed\", output=\"sorted.bed\")\n</code></pre> <p>Functions requiring a genome file: <code>slop</code>, <code>complement</code>, <code>genomecov</code></p>"},{"location":"api/#type-summary","title":"Type Summary","text":"Type Description <code>Interval</code> Single genomic interval <code>IntervalSet</code> Collection of intervals <code>str</code> File paths, chromosome names <code>int</code> Positions, distances <code>float</code> Fractions (0.0-1.0) <code>bool</code> Option flags <code>np.ndarray</code> NumPy arrays for bulk data"},{"location":"api/#exceptions","title":"Exceptions","text":"Exception When Raised <code>ValueError</code> Invalid parameters (e.g., start &gt; end) <code>IOError</code> File not found or I/O errors <code>RuntimeError</code> Processing errors (e.g., unsorted input)"},{"location":"api/file-operations/","title":"File Operations","text":"<p>Streaming functions for processing BED files with O(k) memory complexity.</p> <p>Sorted Input Required</p> <p>All file operations require sorted BED files (by chromosome, then start position).</p>"},{"location":"api/file-operations/#intersect","title":"intersect","text":"<pre><code>def intersect(\n    a: str,\n    b: str,\n    output: str | None = None,\n    write_a: bool = False,\n    write_b: bool = False,\n    fraction: float | None = None,\n    reciprocal: bool = False,\n    count: bool = False,\n    unique: bool = False,\n    no_overlap: bool = False,\n) -&gt; list[Interval] | None\n</code></pre> <p>Find overlapping intervals between two BED files.</p>"},{"location":"api/file-operations/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>a</code> <code>str</code> - Path to file A <code>b</code> <code>str</code> - Path to file B <code>output</code> <code>str \\| None</code> <code>None</code> Output file path. If None, returns list <code>write_a</code> <code>bool</code> <code>False</code> Include original A record in output <code>write_b</code> <code>bool</code> <code>False</code> Include original B record in output <code>fraction</code> <code>float \\| None</code> <code>None</code> Minimum overlap as fraction of A (0.0-1.0) <code>reciprocal</code> <code>bool</code> <code>False</code> Require fraction overlap in both A and B <code>count</code> <code>bool</code> <code>False</code> Report count of overlaps per A interval <code>unique</code> <code>bool</code> <code>False</code> Report each A interval only once <code>no_overlap</code> <code>bool</code> <code>False</code> Report A intervals with no B overlap"},{"location":"api/file-operations/#returns","title":"Returns","text":"<ul> <li><code>list[Interval]</code> if <code>output</code> is None</li> <li><code>None</code> if <code>output</code> is specified (results written to file)</li> </ul>"},{"location":"api/file-operations/#raises","title":"Raises","text":"<ul> <li><code>IOError</code>: File not found or I/O error</li> <li><code>RuntimeError</code>: Processing error (e.g., unsorted input)</li> <li><code>ValueError</code>: Invalid parameter values</li> </ul>"},{"location":"api/file-operations/#examples","title":"Examples","text":"<pre><code>import pygrit\n\n# Basic intersection\noverlaps = pygrit.intersect(\"features.bed\", \"regions.bed\")\n\n# Write to file\npygrit.intersect(\"a.bed\", \"b.bed\", output=\"overlaps.bed\")\n\n# Include original records\npygrit.intersect(\"a.bed\", \"b.bed\", write_a=True, write_b=True, output=\"out.bed\")\n\n# Require 50% overlap\npygrit.intersect(\"a.bed\", \"b.bed\", fraction=0.5, output=\"out.bed\")\n\n# Reciprocal 50% overlap\npygrit.intersect(\"a.bed\", \"b.bed\", fraction=0.5, reciprocal=True, output=\"out.bed\")\n\n# Report each A once\npygrit.intersect(\"a.bed\", \"b.bed\", unique=True, output=\"out.bed\")\n\n# Count overlaps\npygrit.intersect(\"a.bed\", \"b.bed\", count=True, output=\"out.bed\")\n\n# Non-overlapping A intervals\nnon_overlapping = pygrit.intersect(\"a.bed\", \"b.bed\", no_overlap=True)\n</code></pre>"},{"location":"api/file-operations/#merge","title":"merge","text":"<pre><code>def merge(\n    input: str,\n    output: str | None = None,\n    distance: int = 0,\n    strand: bool = False,\n) -&gt; list[Interval] | None\n</code></pre> <p>Merge overlapping or nearby intervals.</p>"},{"location":"api/file-operations/#parameters_1","title":"Parameters","text":"Parameter Type Default Description <code>input</code> <code>str</code> - Path to input BED file <code>output</code> <code>str \\| None</code> <code>None</code> Output file path. If None, returns list <code>distance</code> <code>int</code> <code>0</code> Maximum gap to bridge when merging <code>strand</code> <code>bool</code> <code>False</code> Only merge intervals on same strand"},{"location":"api/file-operations/#returns_1","title":"Returns","text":"<ul> <li><code>list[Interval]</code> if <code>output</code> is None</li> <li><code>None</code> if <code>output</code> is specified</li> </ul>"},{"location":"api/file-operations/#examples_1","title":"Examples","text":"<pre><code># Basic merge\nmerged = pygrit.merge(\"input.bed\")\n\n# Merge intervals within 100bp\nmerged = pygrit.merge(\"input.bed\", distance=100)\n\n# Strand-specific merge\nmerged = pygrit.merge(\"input.bed\", strand=True)\n\n# Write to file\npygrit.merge(\"input.bed\", output=\"merged.bed\")\n</code></pre>"},{"location":"api/file-operations/#subtract","title":"subtract","text":"<pre><code>def subtract(\n    a: str,\n    b: str,\n    output: str | None = None,\n    remove_entire: bool = False,\n    fraction: float | None = None,\n    reciprocal: bool = False,\n) -&gt; list[Interval] | None\n</code></pre> <p>Subtract B intervals from A intervals.</p>"},{"location":"api/file-operations/#parameters_2","title":"Parameters","text":"Parameter Type Default Description <code>a</code> <code>str</code> - Path to file A <code>b</code> <code>str</code> - Path to file B <code>output</code> <code>str \\| None</code> <code>None</code> Output file path. If None, returns list <code>remove_entire</code> <code>bool</code> <code>False</code> Remove entire A interval if any overlap <code>fraction</code> <code>float \\| None</code> <code>None</code> Minimum overlap fraction to subtract <code>reciprocal</code> <code>bool</code> <code>False</code> Require reciprocal fraction"},{"location":"api/file-operations/#returns_2","title":"Returns","text":"<ul> <li><code>list[Interval]</code> if <code>output</code> is None</li> <li><code>None</code> if <code>output</code> is specified</li> </ul>"},{"location":"api/file-operations/#examples_2","title":"Examples","text":"<pre><code># Basic subtraction\nresult = pygrit.subtract(\"features.bed\", \"exclude.bed\")\n\n# Remove entire interval on any overlap\nresult = pygrit.subtract(\"a.bed\", \"b.bed\", remove_entire=True)\n\n# Only subtract significant overlaps\nresult = pygrit.subtract(\"a.bed\", \"b.bed\", fraction=0.5)\n</code></pre>"},{"location":"api/file-operations/#coverage","title":"coverage","text":"<pre><code>def coverage(\n    a: str,\n    b: str,\n    output: str | None = None,\n    histogram: bool = False,\n    mean: bool = False,\n) -&gt; str | None\n</code></pre> <p>Calculate coverage of A regions by B features.</p>"},{"location":"api/file-operations/#parameters_3","title":"Parameters","text":"Parameter Type Default Description <code>a</code> <code>str</code> - Path to regions file <code>b</code> <code>str</code> - Path to reads/features file <code>output</code> <code>str \\| None</code> <code>None</code> Output file path. If None, returns string <code>histogram</code> <code>bool</code> <code>False</code> Report depth histogram <code>mean</code> <code>bool</code> <code>False</code> Report mean depth per region"},{"location":"api/file-operations/#returns_3","title":"Returns","text":"<ul> <li><code>str</code> if <code>output</code> is None (coverage output as string)</li> <li><code>None</code> if <code>output</code> is specified</li> </ul>"},{"location":"api/file-operations/#examples_3","title":"Examples","text":"<pre><code># Basic coverage\nresult = pygrit.coverage(\"regions.bed\", \"reads.bed\")\n\n# With mean depth\nresult = pygrit.coverage(\"regions.bed\", \"reads.bed\", mean=True)\n\n# Histogram output\nresult = pygrit.coverage(\"regions.bed\", \"reads.bed\", histogram=True)\n</code></pre>"},{"location":"api/file-operations/#closest","title":"closest","text":"<pre><code>def closest(\n    a: str,\n    b: str,\n    output: str | None = None,\n    ignore_overlaps: bool = False,\n    ignore_upstream: bool = False,\n    ignore_downstream: bool = False,\n) -&gt; str | None\n</code></pre> <p>Find closest B interval for each A interval.</p>"},{"location":"api/file-operations/#parameters_4","title":"Parameters","text":"Parameter Type Default Description <code>a</code> <code>str</code> - Path to file A <code>b</code> <code>str</code> - Path to file B <code>output</code> <code>str \\| None</code> <code>None</code> Output file path. If None, returns string <code>ignore_overlaps</code> <code>bool</code> <code>False</code> Skip overlapping intervals <code>ignore_upstream</code> <code>bool</code> <code>False</code> Only look downstream (3') <code>ignore_downstream</code> <code>bool</code> <code>False</code> Only look upstream (5')"},{"location":"api/file-operations/#returns_4","title":"Returns","text":"<ul> <li><code>str</code> if <code>output</code> is None (closest output as string)</li> <li><code>None</code> if <code>output</code> is specified</li> </ul>"},{"location":"api/file-operations/#examples_4","title":"Examples","text":"<pre><code># Find closest\nresult = pygrit.closest(\"queries.bed\", \"targets.bed\")\n\n# Ignore overlapping\nresult = pygrit.closest(\"a.bed\", \"b.bed\", ignore_overlaps=True)\n\n# Only downstream\nresult = pygrit.closest(\"a.bed\", \"b.bed\", ignore_upstream=True)\n</code></pre>"},{"location":"api/file-operations/#window","title":"window","text":"<pre><code>def window(\n    a: str,\n    b: str,\n    output: str | None = None,\n    window: int = 1000,\n    left: int | None = None,\n    right: int | None = None,\n    count: bool = False,\n    no_overlap: bool = False,\n) -&gt; str | None\n</code></pre> <p>Find B intervals within window distance of A intervals.</p>"},{"location":"api/file-operations/#parameters_5","title":"Parameters","text":"Parameter Type Default Description <code>a</code> <code>str</code> - Path to file A <code>b</code> <code>str</code> - Path to file B <code>output</code> <code>str \\| None</code> <code>None</code> Output file path. If None, returns string <code>window</code> <code>int</code> <code>1000</code> Window size in base pairs <code>left</code> <code>int \\| None</code> <code>None</code> Left window (overrides <code>window</code>) <code>right</code> <code>int \\| None</code> <code>None</code> Right window (overrides <code>window</code>) <code>count</code> <code>bool</code> <code>False</code> Report count of B in window <code>no_overlap</code> <code>bool</code> <code>False</code> Only report non-overlapping"},{"location":"api/file-operations/#returns_5","title":"Returns","text":"<ul> <li><code>str</code> if <code>output</code> is None (window output as string)</li> <li><code>None</code> if <code>output</code> is specified</li> </ul>"},{"location":"api/file-operations/#examples_5","title":"Examples","text":"<pre><code># Find within 1kb\nresult = pygrit.window(\"genes.bed\", \"enhancers.bed\", window=1000)\n\n# Asymmetric window (5kb upstream, 1kb downstream)\nresult = pygrit.window(\"genes.bed\", \"enhancers.bed\", left=5000, right=1000)\n\n# Count mode\nresult = pygrit.window(\"a.bed\", \"b.bed\", count=True)\n</code></pre>"},{"location":"api/file-operations/#sort","title":"sort","text":"<pre><code>def sort(\n    input: str,\n    output: str | None = None,\n    genome: str | None = None,\n    reverse: bool = False,\n) -&gt; str | None\n</code></pre> <p>Sort a BED file by chromosome and start position.</p>"},{"location":"api/file-operations/#parameters_6","title":"Parameters","text":"Parameter Type Default Description <code>input</code> <code>str</code> - Path to input BED file <code>output</code> <code>str \\| None</code> <code>None</code> Output file path. If None, returns string <code>genome</code> <code>str \\| None</code> <code>None</code> Genome file for chromosome ordering <code>reverse</code> <code>bool</code> <code>False</code> Sort in reverse order"},{"location":"api/file-operations/#returns_6","title":"Returns","text":"<ul> <li><code>str</code> if <code>output</code> is None (sorted output as string)</li> <li><code>None</code> if <code>output</code> is specified</li> </ul>"},{"location":"api/file-operations/#examples_6","title":"Examples","text":"<pre><code># Basic sort\nsorted_bed = pygrit.sort(\"unsorted.bed\")\n\n# Write to file\npygrit.sort(\"unsorted.bed\", output=\"sorted.bed\")\n\n# Reverse sort\npygrit.sort(\"input.bed\", reverse=True, output=\"reversed.bed\")\n\n# Use genome file for chromosome ordering\npygrit.sort(\"input.bed\", genome=\"genome.txt\", output=\"sorted.bed\")\n</code></pre>"},{"location":"api/file-operations/#slop","title":"slop","text":"<pre><code>def slop(\n    input: str,\n    genome: str,\n    output: str | None = None,\n    both: float | None = None,\n    left: float | None = None,\n    right: float | None = None,\n    pct: bool = False,\n) -&gt; str | None\n</code></pre> <p>Extend intervals by a specified amount on each side.</p>"},{"location":"api/file-operations/#parameters_7","title":"Parameters","text":"Parameter Type Default Description <code>input</code> <code>str</code> - Path to input BED file <code>genome</code> <code>str</code> - Path to genome file (chromosome sizes) <code>output</code> <code>str \\| None</code> <code>None</code> Output file path. If None, returns string <code>both</code> <code>float \\| None</code> <code>None</code> Extend both sides by this amount <code>left</code> <code>float \\| None</code> <code>None</code> Extend left (5') side <code>right</code> <code>float \\| None</code> <code>None</code> Extend right (3') side <code>pct</code> <code>bool</code> <code>False</code> Interpret values as percentage of interval length"},{"location":"api/file-operations/#returns_7","title":"Returns","text":"<ul> <li><code>str</code> if <code>output</code> is None (extended intervals as string)</li> <li><code>None</code> if <code>output</code> is specified</li> </ul>"},{"location":"api/file-operations/#examples_7","title":"Examples","text":"<pre><code># Extend both sides by 100bp\nresult = pygrit.slop(\"regions.bed\", \"genome.txt\", both=100.0)\n\n# Asymmetric extension\nresult = pygrit.slop(\"regions.bed\", \"genome.txt\", left=50.0, right=200.0)\n\n# Percentage-based extension (50% of interval length)\nresult = pygrit.slop(\"regions.bed\", \"genome.txt\", both=0.5, pct=True)\n\n# Write to file\npygrit.slop(\"regions.bed\", \"genome.txt\", both=100.0, output=\"extended.bed\")\n</code></pre>"},{"location":"api/file-operations/#complement","title":"complement","text":"<pre><code>def complement(\n    input: str,\n    genome: str,\n    output: str | None = None,\n) -&gt; str | None\n</code></pre> <p>Calculate the complement of intervals (gaps between intervals).</p>"},{"location":"api/file-operations/#parameters_8","title":"Parameters","text":"Parameter Type Default Description <code>input</code> <code>str</code> - Path to input BED file <code>genome</code> <code>str</code> - Path to genome file (chromosome sizes) <code>output</code> <code>str \\| None</code> <code>None</code> Output file path. If None, returns string"},{"location":"api/file-operations/#returns_8","title":"Returns","text":"<ul> <li><code>str</code> if <code>output</code> is None (complement intervals as string)</li> <li><code>None</code> if <code>output</code> is specified</li> </ul>"},{"location":"api/file-operations/#examples_8","title":"Examples","text":"<pre><code># Get gaps between intervals\ngaps = pygrit.complement(\"features.bed\", \"genome.txt\")\n\n# Write to file\npygrit.complement(\"features.bed\", \"genome.txt\", output=\"gaps.bed\")\n</code></pre>"},{"location":"api/file-operations/#genomecov","title":"genomecov","text":"<pre><code>def genomecov(\n    input: str,\n    genome: str,\n    output: str | None = None,\n    bg: bool = False,\n    bga: bool = False,\n    scale: float = 1.0,\n) -&gt; str | None\n</code></pre> <p>Calculate genome-wide coverage.</p>"},{"location":"api/file-operations/#parameters_9","title":"Parameters","text":"Parameter Type Default Description <code>input</code> <code>str</code> - Path to input BED file <code>genome</code> <code>str</code> - Path to genome file (chromosome sizes) <code>output</code> <code>str \\| None</code> <code>None</code> Output file path. If None, returns string <code>bg</code> <code>bool</code> <code>False</code> Output BedGraph format (non-zero regions only) <code>bga</code> <code>bool</code> <code>False</code> Output BedGraph format (all regions, including zero) <code>scale</code> <code>float</code> <code>1.0</code> Scale coverage by this factor"},{"location":"api/file-operations/#returns_9","title":"Returns","text":"<ul> <li><code>str</code> if <code>output</code> is None (coverage output as string)</li> <li><code>None</code> if <code>output</code> is specified</li> </ul>"},{"location":"api/file-operations/#examples_9","title":"Examples","text":"<pre><code># Histogram output (default)\nresult = pygrit.genomecov(\"reads.bed\", \"genome.txt\")\n\n# BedGraph format (non-zero only)\nresult = pygrit.genomecov(\"reads.bed\", \"genome.txt\", bg=True)\n\n# BedGraph with zero coverage regions\nresult = pygrit.genomecov(\"reads.bed\", \"genome.txt\", bga=True)\n\n# Scaled coverage\nresult = pygrit.genomecov(\"reads.bed\", \"genome.txt\", bg=True, scale=0.5)\n</code></pre>"},{"location":"api/file-operations/#jaccard","title":"jaccard","text":"<pre><code>def jaccard(\n    a: str,\n    b: str,\n    output: str | None = None,\n) -&gt; str | None\n</code></pre> <p>Calculate Jaccard similarity between two BED files.</p>"},{"location":"api/file-operations/#parameters_10","title":"Parameters","text":"Parameter Type Default Description <code>a</code> <code>str</code> - Path to file A <code>b</code> <code>str</code> - Path to file B <code>output</code> <code>str \\| None</code> <code>None</code> Output file path. If None, returns string"},{"location":"api/file-operations/#returns_10","title":"Returns","text":"<ul> <li><code>str</code> if <code>output</code> is None (Jaccard statistics as string)</li> <li><code>None</code> if <code>output</code> is specified</li> </ul>"},{"location":"api/file-operations/#examples_10","title":"Examples","text":"<pre><code># Calculate Jaccard similarity\nresult = pygrit.jaccard(\"set_a.bed\", \"set_b.bed\")\nprint(result)  # intersection, union, jaccard, n_intersections\n\n# Write to file\npygrit.jaccard(\"set_a.bed\", \"set_b.bed\", output=\"similarity.txt\")\n</code></pre>"},{"location":"api/file-operations/#multiinter","title":"multiinter","text":"<pre><code>def multiinter(\n    inputs: list[str],\n    output: str | None = None,\n    cluster: bool = False,\n) -&gt; str | None\n</code></pre> <p>Find intervals that overlap across multiple BED files.</p>"},{"location":"api/file-operations/#parameters_11","title":"Parameters","text":"Parameter Type Default Description <code>inputs</code> <code>list[str]</code> - List of paths to input BED files (minimum 2) <code>output</code> <code>str \\| None</code> <code>None</code> Output file path. If None, returns string <code>cluster</code> <code>bool</code> <code>False</code> Cluster overlapping intervals"},{"location":"api/file-operations/#returns_11","title":"Returns","text":"<ul> <li><code>str</code> if <code>output</code> is None (multiinter output as string)</li> <li><code>None</code> if <code>output</code> is specified</li> </ul>"},{"location":"api/file-operations/#raises_1","title":"Raises","text":"<ul> <li><code>ValueError</code>: If fewer than 2 input files provided</li> </ul>"},{"location":"api/file-operations/#examples_11","title":"Examples","text":"<pre><code># Find regions covered by multiple files\nresult = pygrit.multiinter([\"a.bed\", \"b.bed\", \"c.bed\"])\n\n# With clustering\nresult = pygrit.multiinter([\"a.bed\", \"b.bed\"], cluster=True)\n\n# Write to file\npygrit.multiinter([\"a.bed\", \"b.bed\", \"c.bed\"], output=\"overlap.bed\")\n</code></pre>"},{"location":"api/file-operations/#generate","title":"generate","text":"<pre><code>def generate(\n    output_dir: str,\n    num_intervals: int = 10000,\n    num_chroms: int = 5,\n    chrom_size: int = 100000000,\n    len_min: int = 50,\n    len_max: int = 5000,\n    mode: str = \"uniform\",\n    num_files: int = 2,\n    sorted: bool = True,\n    seed: int | None = None,\n) -&gt; dict\n</code></pre> <p>Generate synthetic BED files for testing and benchmarking.</p>"},{"location":"api/file-operations/#parameters_12","title":"Parameters","text":"Parameter Type Default Description <code>output_dir</code> <code>str</code> - Output directory path <code>num_intervals</code> <code>int</code> <code>10000</code> Number of intervals per file <code>num_chroms</code> <code>int</code> <code>5</code> Number of chromosomes <code>chrom_size</code> <code>int</code> <code>100000000</code> Size of each chromosome <code>len_min</code> <code>int</code> <code>50</code> Minimum interval length <code>len_max</code> <code>int</code> <code>5000</code> Maximum interval length <code>mode</code> <code>str</code> <code>\"uniform\"</code> Distribution mode: \"uniform\", \"balanced\", \"clustered\" <code>num_files</code> <code>int</code> <code>2</code> Number of files to generate <code>sorted</code> <code>bool</code> <code>True</code> Generate sorted output <code>seed</code> <code>int \\| None</code> <code>None</code> Random seed for reproducibility"},{"location":"api/file-operations/#returns_12","title":"Returns","text":"<ul> <li><code>dict</code> with generation statistics:<ul> <li><code>total_files</code>: Number of files generated</li> <li><code>total_intervals</code>: Total intervals across all files</li> <li><code>elapsed_secs</code>: Time taken in seconds</li> </ul> </li> </ul>"},{"location":"api/file-operations/#raises_2","title":"Raises","text":"<ul> <li><code>ValueError</code>: If invalid mode specified</li> </ul>"},{"location":"api/file-operations/#examples_12","title":"Examples","text":"<pre><code># Generate test files\nstats = pygrit.generate(\"./test_data\", num_intervals=10000)\nprint(f\"Generated {stats['total_files']} files\")\n\n# Clustered distribution\nstats = pygrit.generate(\"./data\", mode=\"clustered\", seed=42)\n\n# Reproducible generation\nstats = pygrit.generate(\"./data\", num_intervals=5000, seed=12345)\n</code></pre>"},{"location":"api/interval/","title":"Interval","text":"<p>A genomic interval with chromosome, start, and end coordinates.</p>"},{"location":"api/interval/#overview","title":"Overview","text":"<p>The <code>Interval</code> class represents a single genomic region using 0-based, half-open coordinates (BED format).</p> <pre><code>import pygrit\n\niv = pygrit.Interval(\"chr1\", 100, 200)\n</code></pre>"},{"location":"api/interval/#constructor","title":"Constructor","text":""},{"location":"api/interval/#intervalchrom-start-end","title":"<code>Interval(chrom, start, end)</code>","text":"<p>Create a new interval.</p> <p>Parameters:</p> Parameter Type Description <code>chrom</code> <code>str</code> Chromosome name (e.g., \"chr1\", \"chrX\") <code>start</code> <code>int</code> Start position (0-based, inclusive) <code>end</code> <code>int</code> End position (exclusive) <p>Returns: <code>Interval</code></p> <p>Raises: <code>ValueError</code> if <code>start &gt; end</code></p> <p>Example:</p> <pre><code># Create an interval covering positions 100-199\niv = pygrit.Interval(\"chr1\", 100, 200)\n\n# Invalid: start &gt; end\ntry:\n    pygrit.Interval(\"chr1\", 200, 100)\nexcept ValueError as e:\n    print(e)  # \"start (200) cannot be greater than end (100)\"\n</code></pre>"},{"location":"api/interval/#properties","title":"Properties","text":""},{"location":"api/interval/#chrom","title":"<code>chrom</code>","text":"<p>The chromosome name.</p> <p>Type: <code>str</code></p> <pre><code>iv = pygrit.Interval(\"chr1\", 100, 200)\niv.chrom  # \"chr1\"\n</code></pre>"},{"location":"api/interval/#start","title":"<code>start</code>","text":"<p>The start position (0-based, inclusive).</p> <p>Type: <code>int</code></p> <pre><code>iv = pygrit.Interval(\"chr1\", 100, 200)\niv.start  # 100\n</code></pre>"},{"location":"api/interval/#end","title":"<code>end</code>","text":"<p>The end position (exclusive).</p> <p>Type: <code>int</code></p> <pre><code>iv = pygrit.Interval(\"chr1\", 100, 200)\niv.end  # 200\n</code></pre>"},{"location":"api/interval/#methods","title":"Methods","text":""},{"location":"api/interval/#overlapsother","title":"<code>overlaps(other)</code>","text":"<p>Check if this interval overlaps another.</p> <p>Parameters:</p> Parameter Type Description <code>other</code> <code>Interval</code> The interval to check against <p>Returns: <code>bool</code> - <code>True</code> if intervals overlap, <code>False</code> otherwise</p> <p>Example:</p> <pre><code>iv1 = pygrit.Interval(\"chr1\", 100, 200)\niv2 = pygrit.Interval(\"chr1\", 150, 250)\niv3 = pygrit.Interval(\"chr1\", 300, 400)\niv4 = pygrit.Interval(\"chr2\", 100, 200)\n\niv1.overlaps(iv2)  # True (overlap at 150-200)\niv1.overlaps(iv3)  # False (no overlap)\niv1.overlaps(iv4)  # False (different chromosomes)\n</code></pre>"},{"location":"api/interval/#overlap_lengthother","title":"<code>overlap_length(other)</code>","text":"<p>Calculate the number of overlapping bases.</p> <p>Parameters:</p> Parameter Type Description <code>other</code> <code>Interval</code> The interval to check against <p>Returns: <code>int</code> - Number of overlapping bases (0 if no overlap)</p> <p>Example:</p> <pre><code>iv1 = pygrit.Interval(\"chr1\", 100, 200)\niv2 = pygrit.Interval(\"chr1\", 150, 250)\n\niv1.overlap_length(iv2)  # 50 (positions 150-199)\n</code></pre>"},{"location":"api/interval/#distance_toother","title":"<code>distance_to(other)</code>","text":"<p>Calculate the distance to another interval.</p> <p>Parameters:</p> Parameter Type Description <code>other</code> <code>Interval</code> The interval to measure distance to <p>Returns: <code>int | None</code></p> <ul> <li><code>0</code> if intervals overlap</li> <li>Positive integer for the gap between non-overlapping intervals</li> <li><code>None</code> if intervals are on different chromosomes</li> </ul> <p>Example:</p> <pre><code>iv1 = pygrit.Interval(\"chr1\", 100, 200)\niv2 = pygrit.Interval(\"chr1\", 150, 250)\niv3 = pygrit.Interval(\"chr1\", 300, 400)\niv4 = pygrit.Interval(\"chr2\", 100, 200)\n\niv1.distance_to(iv2)  # 0 (overlapping)\niv1.distance_to(iv3)  # 100 (gap from 200 to 300)\niv1.distance_to(iv4)  # None (different chromosomes)\n</code></pre>"},{"location":"api/interval/#to_tuple","title":"<code>to_tuple()</code>","text":"<p>Convert to a tuple.</p> <p>Returns: <code>tuple[str, int, int]</code> - <code>(chrom, start, end)</code></p> <p>Example:</p> <pre><code>iv = pygrit.Interval(\"chr1\", 100, 200)\niv.to_tuple()  # (\"chr1\", 100, 200)\n\n# Useful for unpacking\nchrom, start, end = iv.to_tuple()\n</code></pre>"},{"location":"api/interval/#special-methods","title":"Special Methods","text":""},{"location":"api/interval/#__len__","title":"<code>__len__()</code>","text":"<p>Return the length of the interval.</p> <p>Returns: <code>int</code> - <code>end - start</code></p> <pre><code>iv = pygrit.Interval(\"chr1\", 100, 200)\nlen(iv)  # 100\n</code></pre>"},{"location":"api/interval/#__str__","title":"<code>__str__()</code>","text":"<p>Return BED format string.</p> <p>Returns: <code>str</code> - Tab-separated <code>chrom\\tstart\\tend</code></p> <pre><code>iv = pygrit.Interval(\"chr1\", 100, 200)\nstr(iv)  # \"chr1\\t100\\t200\"\n</code></pre>"},{"location":"api/interval/#__repr__","title":"<code>__repr__()</code>","text":"<p>Return Python representation.</p> <p>Returns: <code>str</code> - <code>Interval('chrom', start, end)</code></p> <pre><code>iv = pygrit.Interval(\"chr1\", 100, 200)\nrepr(iv)  # \"Interval('chr1', 100, 200)\"\n</code></pre>"},{"location":"api/interval/#__eq__other","title":"<code>__eq__(other)</code>","text":"<p>Check equality with another interval.</p> <p>Returns: <code>bool</code></p> <pre><code>iv1 = pygrit.Interval(\"chr1\", 100, 200)\niv2 = pygrit.Interval(\"chr1\", 100, 200)\niv3 = pygrit.Interval(\"chr1\", 100, 201)\n\niv1 == iv2  # True\niv1 == iv3  # False\n</code></pre>"},{"location":"api/interval/#__hash__","title":"<code>__hash__()</code>","text":"<p>Return hash value for use in sets and dicts.</p> <p>Returns: <code>int</code></p> <pre><code>iv1 = pygrit.Interval(\"chr1\", 100, 200)\niv2 = pygrit.Interval(\"chr1\", 100, 200)\n\n# Use in sets\nintervals = {iv1, iv2}\nlen(intervals)  # 1 (duplicates removed)\n\n# Use as dict keys\ndata = {iv1: \"exon1\"}\ndata[iv2]  # \"exon1\"\n</code></pre>"},{"location":"api/interval/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/interval/#working-with-multiple-intervals","title":"Working with Multiple Intervals","text":"<pre><code>intervals = [\n    pygrit.Interval(\"chr1\", 100, 200),\n    pygrit.Interval(\"chr1\", 150, 250),\n    pygrit.Interval(\"chr1\", 300, 400),\n]\n\n# Find all overlapping pairs\nfor i, iv1 in enumerate(intervals):\n    for iv2 in intervals[i+1:]:\n        if iv1.overlaps(iv2):\n            print(f\"{iv1} overlaps {iv2}\")\n</code></pre>"},{"location":"api/interval/#converting-to-other-formats","title":"Converting to Other Formats","text":"<pre><code>iv = pygrit.Interval(\"chr1\", 100, 200)\n\n# To BED line\nbed_line = str(iv)\n\n# To tuple\nt = iv.to_tuple()\n\n# To dict\nd = {\"chrom\": iv.chrom, \"start\": iv.start, \"end\": iv.end}\n</code></pre>"},{"location":"api/interval_set/","title":"IntervalSet","text":"<p>A collection of genomic intervals with bulk operations.</p>"},{"location":"api/interval_set/#overview","title":"Overview","text":"<p>The <code>IntervalSet</code> class provides efficient storage and operations for multiple intervals.</p> <pre><code>import pygrit\n\n# Create from list\nintervals = pygrit.IntervalSet.from_intervals([\n    pygrit.Interval(\"chr1\", 100, 200),\n    pygrit.Interval(\"chr1\", 300, 400),\n])\n</code></pre>"},{"location":"api/interval_set/#constructors","title":"Constructors","text":""},{"location":"api/interval_set/#intervalset_1","title":"<code>IntervalSet()</code>","text":"<p>Create an empty IntervalSet.</p> <p>Returns: <code>IntervalSet</code></p> <pre><code>intervals = pygrit.IntervalSet()\nlen(intervals)  # 0\n</code></pre>"},{"location":"api/interval_set/#intervalsetfrom_intervalsintervals","title":"<code>IntervalSet.from_intervals(intervals)</code>","text":"<p>Create an IntervalSet from a list of Interval objects.</p> <p>Parameters:</p> Parameter Type Description <code>intervals</code> <code>list[Interval]</code> List of Interval objects <p>Returns: <code>IntervalSet</code></p> <pre><code>intervals = pygrit.IntervalSet.from_intervals([\n    pygrit.Interval(\"chr1\", 100, 200),\n    pygrit.Interval(\"chr1\", 300, 400),\n])\n</code></pre>"},{"location":"api/interval_set/#methods","title":"Methods","text":""},{"location":"api/interval_set/#addinterval","title":"<code>add(interval)</code>","text":"<p>Add an interval to the set.</p> <p>Parameters:</p> Parameter Type Description <code>interval</code> <code>Interval</code> The interval to add <p>Returns: <code>None</code></p> <pre><code>intervals = pygrit.IntervalSet()\nintervals.add(pygrit.Interval(\"chr1\", 100, 200))\nintervals.add(pygrit.Interval(\"chr1\", 300, 400))\nlen(intervals)  # 2\n</code></pre>"},{"location":"api/interval_set/#to_list","title":"<code>to_list()</code>","text":"<p>Convert to a list of Interval objects.</p> <p>Returns: <code>list[Interval]</code></p> <pre><code>intervals = pygrit.read_bed(\"regions.bed\")\nfor iv in intervals.to_list():\n    print(f\"{iv.chrom}:{iv.start}-{iv.end}\")\n</code></pre>"},{"location":"api/interval_set/#mergedistance0","title":"<code>merge(distance=0)</code>","text":"<p>Merge overlapping or nearby intervals.</p> <p>Parameters:</p> Parameter Type Default Description <code>distance</code> <code>int</code> <code>0</code> Maximum gap to bridge when merging <p>Returns: <code>IntervalSet</code> - New IntervalSet with merged intervals</p> <p>Example:</p> <pre><code>intervals = pygrit.IntervalSet.from_intervals([\n    pygrit.Interval(\"chr1\", 100, 200),\n    pygrit.Interval(\"chr1\", 150, 250),  # Overlaps\n    pygrit.Interval(\"chr1\", 500, 600),  # Separate\n])\n\n# Merge overlapping only\nmerged = intervals.merge()\n# Result: [chr1:100-250, chr1:500-600]\n\n# Merge with distance tolerance\nmerged = intervals.merge(distance=300)\n# Result: [chr1:100-600]\n</code></pre>"},{"location":"api/interval_set/#intersectother-fractionnone-reciprocalfalse","title":"<code>intersect(other, fraction=None, reciprocal=False)</code>","text":"<p>Find intervals that overlap with another IntervalSet.</p> <p>Parameters:</p> Parameter Type Default Description <code>other</code> <code>IntervalSet</code> - IntervalSet to intersect with <code>fraction</code> <code>float \\| None</code> <code>None</code> Minimum overlap fraction (0.0-1.0) <code>reciprocal</code> <code>bool</code> <code>False</code> Require reciprocal overlap fraction <p>Returns: <code>IntervalSet</code> - Intervals from self that overlap with other</p> <p>Example:</p> <pre><code>set_a = pygrit.IntervalSet.from_intervals([\n    pygrit.Interval(\"chr1\", 100, 200),  # 100bp\n    pygrit.Interval(\"chr1\", 300, 400),  # 100bp\n])\n\nset_b = pygrit.IntervalSet.from_intervals([\n    pygrit.Interval(\"chr1\", 150, 350),  # Overlaps both\n])\n\n# Basic intersection\noverlapping = set_a.intersect(set_b)\n# Both intervals overlap\n\n# With fraction requirement (50% of A must overlap)\noverlapping = set_a.intersect(set_b, fraction=0.5)\n# First: 50bp overlap / 100bp = 50% \u2713\n# Second: 50bp overlap / 100bp = 50% \u2713\n\n# With reciprocal fraction\noverlapping = set_a.intersect(set_b, fraction=0.3, reciprocal=True)\n# Also requires 30% of B to overlap\n</code></pre>"},{"location":"api/interval_set/#non_overlappingother","title":"<code>non_overlapping(other)</code>","text":"<p>Find intervals that don't overlap with another IntervalSet.</p> <p>Parameters:</p> Parameter Type Description <code>other</code> <code>IntervalSet</code> IntervalSet to check against <p>Returns: <code>IntervalSet</code> - Intervals from self that don't overlap with other</p> <p>Example:</p> <pre><code>set_a = pygrit.IntervalSet.from_intervals([\n    pygrit.Interval(\"chr1\", 100, 200),\n    pygrit.Interval(\"chr1\", 300, 400),\n    pygrit.Interval(\"chr1\", 500, 600),\n])\n\nset_b = pygrit.IntervalSet.from_intervals([\n    pygrit.Interval(\"chr1\", 150, 250),  # Overlaps first\n])\n\nnon_overlapping = set_a.non_overlapping(set_b)\n# Result: [chr1:300-400, chr1:500-600]\n</code></pre>"},{"location":"api/interval_set/#sort","title":"<code>sort()</code>","text":"<p>Sort intervals in place by chromosome and start position.</p> <p>Returns: <code>None</code></p> <pre><code>intervals = pygrit.IntervalSet.from_intervals([\n    pygrit.Interval(\"chr2\", 100, 200),\n    pygrit.Interval(\"chr1\", 300, 400),\n    pygrit.Interval(\"chr1\", 100, 200),\n])\n\nintervals.sort()\n# Now: [chr1:100-200, chr1:300-400, chr2:100-200]\n</code></pre>"},{"location":"api/interval_set/#to_numpy","title":"<code>to_numpy()</code>","text":"<p>Convert to a NumPy array.</p> <p>Returns: <code>np.ndarray</code> - Shape <code>(n, 2)</code> with columns <code>[start, end]</code></p> <p>Note</p> <p>This only returns start/end coordinates. Chromosome information is not included in the array.</p> <pre><code>import numpy as np\n\nintervals = pygrit.IntervalSet.from_intervals([\n    pygrit.Interval(\"chr1\", 100, 200),\n    pygrit.Interval(\"chr1\", 300, 400),\n])\n\narr = intervals.to_numpy()\n# array([[100, 200],\n#        [300, 400]])\n\n# Calculate lengths\nlengths = arr[:, 1] - arr[:, 0]\n</code></pre>"},{"location":"api/interval_set/#special-methods","title":"Special Methods","text":""},{"location":"api/interval_set/#__len__","title":"<code>__len__()</code>","text":"<p>Return the number of intervals.</p> <p>Returns: <code>int</code></p> <pre><code>intervals = pygrit.read_bed(\"regions.bed\")\nlen(intervals)  # Number of intervals\n</code></pre>"},{"location":"api/interval_set/#__getitem__index","title":"<code>__getitem__(index)</code>","text":"<p>Access interval by index.</p> <p>Parameters:</p> Parameter Type Description <code>index</code> <code>int</code> Index (supports negative indexing) <p>Returns: <code>Interval</code></p> <p>Raises: <code>IndexError</code> if index is out of range</p> <pre><code>intervals = pygrit.read_bed(\"regions.bed\")\nfirst = intervals[0]\nlast = intervals[-1]\n</code></pre>"},{"location":"api/interval_set/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/interval_set/#iteration","title":"Iteration","text":"<pre><code>intervals = pygrit.read_bed(\"regions.bed\")\n\n# Using to_list()\nfor iv in intervals.to_list():\n    print(iv)\n\n# Using indexing\nfor i in range(len(intervals)):\n    print(intervals[i])\n</code></pre>"},{"location":"api/interval_set/#filtering","title":"Filtering","text":"<pre><code>intervals = pygrit.read_bed(\"regions.bed\")\n\n# Filter by chromosome\nchr1_intervals = [\n    iv for iv in intervals.to_list()\n    if iv.chrom == \"chr1\"\n]\n\n# Filter by length\nlong_intervals = [\n    iv for iv in intervals.to_list()\n    if len(iv) &gt; 1000\n]\n\n# Create new IntervalSet from filtered\nfiltered = pygrit.IntervalSet.from_intervals(long_intervals)\n</code></pre>"},{"location":"api/interval_set/#chaining-operations","title":"Chaining Operations","text":"<pre><code>intervals = pygrit.read_bed(\"regions.bed\")\n\n# Sort, merge, then filter\nintervals.sort()\nmerged = intervals.merge(distance=100)\n\n# Further operations\nfinal = merged.non_overlapping(exclusions)\n</code></pre>"},{"location":"api/io/","title":"I/O Functions","text":"<p>Functions for reading and parsing genomic interval data.</p>"},{"location":"api/io/#read_bed","title":"read_bed","text":"<pre><code>def read_bed(path: str) -&gt; IntervalSet\n</code></pre> <p>Read intervals from a BED file.</p>"},{"location":"api/io/#parameters","title":"Parameters","text":"Parameter Type Description <code>path</code> <code>str</code> Path to the BED file"},{"location":"api/io/#returns","title":"Returns","text":"<p><code>IntervalSet</code> containing all intervals from the file.</p>"},{"location":"api/io/#raises","title":"Raises","text":"<ul> <li><code>IOError</code>: File not found or I/O error</li> </ul>"},{"location":"api/io/#example","title":"Example","text":"<pre><code>import pygrit\n\n# Read BED file\nintervals = pygrit.read_bed(\"regions.bed\")\n\nprint(f\"Loaded {len(intervals)} intervals\")\n\n# Access intervals\nfirst = intervals[0]\nprint(f\"First: {first.chrom}:{first.start}-{first.end}\")\n</code></pre>"},{"location":"api/io/#notes","title":"Notes","text":"<ul> <li>Reads the first 3 columns (chrom, start, end)</li> <li>Additional columns are ignored</li> <li>Empty lines and comment lines (starting with #) are skipped</li> </ul>"},{"location":"api/io/#parse_bed","title":"parse_bed","text":"<pre><code>def parse_bed(content: str) -&gt; IntervalSet\n</code></pre> <p>Parse intervals from a BED-formatted string.</p>"},{"location":"api/io/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>content</code> <code>str</code> BED-formatted string content"},{"location":"api/io/#returns_1","title":"Returns","text":"<p><code>IntervalSet</code> containing parsed intervals.</p>"},{"location":"api/io/#example_1","title":"Example","text":"<pre><code>import pygrit\n\n# Parse BED content from string\ncontent = \"\"\"chr1\\t100\\t200\nchr1\\t300\\t400\nchr2\\t500\\t600\n\"\"\"\n\nintervals = pygrit.parse_bed(content)\nprint(f\"Parsed {len(intervals)} intervals\")\n</code></pre>"},{"location":"api/io/#use-cases","title":"Use Cases","text":"<pre><code># Parse from subprocess output\nimport subprocess\n\nresult = subprocess.run(\n    [\"some_tool\", \"output.bed\"],\n    capture_output=True,\n    text=True\n)\nintervals = pygrit.parse_bed(result.stdout)\n\n# Parse from HTTP response\nimport requests\n\nresponse = requests.get(\"https://example.com/data.bed\")\nintervals = pygrit.parse_bed(response.text)\n\n# Parse from multi-line string\ncontent = \"\\n\".join([\n    \"chr1\\t100\\t200\",\n    \"chr1\\t300\\t400\",\n])\nintervals = pygrit.parse_bed(content)\n</code></pre>"},{"location":"api/io/#from_numpy","title":"from_numpy","text":"<pre><code>def from_numpy(chrom: str, arr: np.ndarray) -&gt; IntervalSet\n</code></pre> <p>Create an IntervalSet from a NumPy array.</p>"},{"location":"api/io/#parameters_2","title":"Parameters","text":"Parameter Type Description <code>chrom</code> <code>str</code> Chromosome name for all intervals <code>arr</code> <code>np.ndarray</code> Array with shape <code>(n, 2)</code> containing <code>[start, end]</code> pairs"},{"location":"api/io/#returns_2","title":"Returns","text":"<p><code>IntervalSet</code> with <code>n</code> intervals, all on the specified chromosome.</p>"},{"location":"api/io/#raises_1","title":"Raises","text":"<ul> <li><code>ValueError</code>: If array shape is not <code>(n, 2)</code></li> </ul>"},{"location":"api/io/#example_2","title":"Example","text":"<pre><code>import numpy as np\nimport pygrit\n\n# Create from NumPy array\narr = np.array([\n    [100, 200],\n    [300, 400],\n    [500, 600],\n], dtype=np.int64)\n\nintervals = pygrit.from_numpy(\"chr1\", arr)\nprint(f\"Created {len(intervals)} intervals\")\n\n# Verify\nfor iv in intervals.to_list():\n    print(iv)\n# chr1    100    200\n# chr1    300    400\n# chr1    500    600\n</code></pre>"},{"location":"api/io/#use-cases_1","title":"Use Cases","text":"<pre><code># Generate intervals programmatically\nimport numpy as np\n\n# Create sliding windows\nwindow_size = 1000\nstep = 500\nstarts = np.arange(0, 100000, step)\nends = starts + window_size\n\narr = np.column_stack([starts, ends])\nwindows = pygrit.from_numpy(\"chr1\", arr)\n\n# From pandas DataFrame\nimport pandas as pd\n\ndf = pd.DataFrame({\n    \"start\": [100, 300, 500],\n    \"end\": [200, 400, 600],\n})\n\narr = df[[\"start\", \"end\"]].to_numpy()\nintervals = pygrit.from_numpy(\"chr1\", arr)\n\n# Random intervals\nnp.random.seed(42)\nn_intervals = 1000\nstarts = np.sort(np.random.randint(0, 1000000, n_intervals))\nlengths = np.random.randint(100, 1000, n_intervals)\nends = starts + lengths\n\narr = np.column_stack([starts, ends])\nrandom_intervals = pygrit.from_numpy(\"chr1\", arr)\n</code></pre>"},{"location":"api/io/#notes_1","title":"Notes","text":"<ul> <li>All intervals will have the same chromosome</li> <li>For multiple chromosomes, create separate IntervalSets and process them</li> <li>Array dtype should be integer (int32, int64, uint32, etc.)</li> </ul>"},{"location":"api/io/#round-trip-example","title":"Round-Trip Example","text":"<pre><code>import numpy as np\nimport pygrit\n\n# Read from file\nintervals = pygrit.read_bed(\"regions.bed\")\n\n# Convert to NumPy for analysis\narr = intervals.to_numpy()\n\n# Analyze\nlengths = arr[:, 1] - arr[:, 0]\nprint(f\"Mean length: {np.mean(lengths):.1f}\")\nprint(f\"Total coverage: {np.sum(lengths)}\")\n\n# Modify (extend by 100bp on each side)\narr[:, 0] = np.maximum(0, arr[:, 0] - 100)\narr[:, 1] = arr[:, 1] + 100\n\n# Convert back (assuming single chromosome)\nextended = pygrit.from_numpy(\"chr1\", arr)\n\n# Merge overlapping extended intervals\nmerged = extended.merge()\n</code></pre>"},{"location":"examples/numpy/","title":"NumPy Integration","text":"<p>pygrit provides seamless integration with NumPy for numerical analysis of genomic intervals.</p>"},{"location":"examples/numpy/#converting-between-formats","title":"Converting Between Formats","text":""},{"location":"examples/numpy/#intervalset-to-numpy","title":"IntervalSet to NumPy","text":"<pre><code>import numpy as np\nimport pygrit\n\n# Read intervals\nintervals = pygrit.read_bed(\"regions.bed\")\n\n# Convert to NumPy array\narr = intervals.to_numpy()\nprint(arr.shape)  # (n_intervals, 2)\nprint(arr.dtype)  # int64\n\n# Columns are [start, end]\nstarts = arr[:, 0]\nends = arr[:, 1]\n</code></pre>"},{"location":"examples/numpy/#numpy-to-intervalset","title":"NumPy to IntervalSet","text":"<pre><code>import numpy as np\nimport pygrit\n\n# Create array\narr = np.array([\n    [100, 200],\n    [300, 400],\n    [500, 600],\n], dtype=np.int64)\n\n# Convert to IntervalSet\nintervals = pygrit.from_numpy(\"chr1\", arr)\n</code></pre>"},{"location":"examples/numpy/#statistical-analysis","title":"Statistical Analysis","text":""},{"location":"examples/numpy/#basic-statistics","title":"Basic Statistics","text":"<pre><code>import numpy as np\nimport pygrit\n\nintervals = pygrit.read_bed(\"peaks.bed\")\narr = intervals.to_numpy()\n\n# Calculate lengths\nlengths = arr[:, 1] - arr[:, 0]\n\nprint(f\"Count: {len(lengths)}\")\nprint(f\"Mean length: {np.mean(lengths):.1f} bp\")\nprint(f\"Median length: {np.median(lengths):.1f} bp\")\nprint(f\"Std dev: {np.std(lengths):.1f} bp\")\nprint(f\"Min: {np.min(lengths)} bp\")\nprint(f\"Max: {np.max(lengths)} bp\")\nprint(f\"Total coverage: {np.sum(lengths):,} bp\")\n</code></pre>"},{"location":"examples/numpy/#percentiles","title":"Percentiles","text":"<pre><code>import numpy as np\nimport pygrit\n\nintervals = pygrit.read_bed(\"peaks.bed\")\narr = intervals.to_numpy()\nlengths = arr[:, 1] - arr[:, 0]\n\n# Percentiles\npercentiles = [10, 25, 50, 75, 90]\nvalues = np.percentile(lengths, percentiles)\n\nfor p, v in zip(percentiles, values):\n    print(f\"P{p}: {v:.0f} bp\")\n</code></pre>"},{"location":"examples/numpy/#histogram","title":"Histogram","text":"<pre><code>import numpy as np\nimport pygrit\n\nintervals = pygrit.read_bed(\"peaks.bed\")\narr = intervals.to_numpy()\nlengths = arr[:, 1] - arr[:, 0]\n\n# Create histogram\nhist, bin_edges = np.histogram(lengths, bins=50)\n\nprint(\"Length Distribution:\")\nfor i, count in enumerate(hist):\n    if count &gt; 0:\n        print(f\"  {bin_edges[i]:.0f}-{bin_edges[i+1]:.0f}: {count}\")\n</code></pre>"},{"location":"examples/numpy/#filtering-and-selection","title":"Filtering and Selection","text":""},{"location":"examples/numpy/#filter-by-length","title":"Filter by Length","text":"<pre><code>import numpy as np\nimport pygrit\n\nintervals = pygrit.read_bed(\"regions.bed\")\narr = intervals.to_numpy()\n\n# Calculate lengths\nlengths = arr[:, 1] - arr[:, 0]\n\n# Filter: keep intervals &gt; 1000 bp\nmask = lengths &gt; 1000\nfiltered_arr = arr[mask]\n\n# Convert back\nlong_intervals = pygrit.from_numpy(\"chr1\", filtered_arr)\nprint(f\"Kept {len(long_intervals)} / {len(intervals)} intervals\")\n</code></pre>"},{"location":"examples/numpy/#filter-by-position","title":"Filter by Position","text":"<pre><code>import numpy as np\nimport pygrit\n\nintervals = pygrit.read_bed(\"regions.bed\")\narr = intervals.to_numpy()\n\n# Keep intervals in a specific region\nregion_start = 1_000_000\nregion_end = 2_000_000\n\nmask = (arr[:, 0] &gt;= region_start) &amp; (arr[:, 1] &lt;= region_end)\nregion_intervals = pygrit.from_numpy(\"chr1\", arr[mask])\n</code></pre>"},{"location":"examples/numpy/#top-n-by-length","title":"Top N by Length","text":"<pre><code>import numpy as np\nimport pygrit\n\nintervals = pygrit.read_bed(\"peaks.bed\")\narr = intervals.to_numpy()\n\n# Get top 100 longest intervals\nlengths = arr[:, 1] - arr[:, 0]\ntop_indices = np.argsort(lengths)[-100:][::-1]  # Top 100, descending\n\ntop_intervals = pygrit.from_numpy(\"chr1\", arr[top_indices])\n</code></pre>"},{"location":"examples/numpy/#transformations","title":"Transformations","text":""},{"location":"examples/numpy/#extend-intervals","title":"Extend Intervals","text":"<pre><code>import numpy as np\nimport pygrit\n\nintervals = pygrit.read_bed(\"peaks.bed\")\narr = intervals.to_numpy()\n\n# Extend by 500bp on each side\nextension = 500\narr[:, 0] = np.maximum(0, arr[:, 0] - extension)  # Don't go below 0\narr[:, 1] = arr[:, 1] + extension\n\nextended = pygrit.from_numpy(\"chr1\", arr)\n# Merge overlapping after extension\nmerged = extended.merge()\n</code></pre>"},{"location":"examples/numpy/#resize-to-fixed-width","title":"Resize to Fixed Width","text":"<pre><code>import numpy as np\nimport pygrit\n\nintervals = pygrit.read_bed(\"peaks.bed\")\narr = intervals.to_numpy()\n\n# Resize all intervals to 1000bp centered on midpoint\ntarget_width = 1000\nmidpoints = (arr[:, 0] + arr[:, 1]) // 2\nhalf_width = target_width // 2\n\nnew_arr = np.column_stack([\n    np.maximum(0, midpoints - half_width),\n    midpoints + half_width,\n])\n\nresized = pygrit.from_numpy(\"chr1\", new_arr)\n</code></pre>"},{"location":"examples/numpy/#shift-intervals","title":"Shift Intervals","text":"<pre><code>import numpy as np\nimport pygrit\n\nintervals = pygrit.read_bed(\"regions.bed\")\narr = intervals.to_numpy()\n\n# Shift all intervals by 1000bp\nshift = 1000\narr[:, 0] += shift\narr[:, 1] += shift\n\nshifted = pygrit.from_numpy(\"chr1\", arr)\n</code></pre>"},{"location":"examples/numpy/#generating-intervals","title":"Generating Intervals","text":""},{"location":"examples/numpy/#sliding-windows","title":"Sliding Windows","text":"<pre><code>import numpy as np\nimport pygrit\n\ndef create_sliding_windows(chrom: str, chrom_length: int,\n                           window_size: int, step: int) -&gt; pygrit.IntervalSet:\n    \"\"\"Create sliding windows across a chromosome.\"\"\"\n    starts = np.arange(0, chrom_length - window_size + 1, step)\n    ends = starts + window_size\n\n    arr = np.column_stack([starts, ends])\n    return pygrit.from_numpy(chrom, arr)\n\n# Create 1kb windows with 500bp step\nwindows = create_sliding_windows(\"chr1\", 10_000_000, 1000, 500)\nprint(f\"Created {len(windows)} windows\")\n</code></pre>"},{"location":"examples/numpy/#random-intervals","title":"Random Intervals","text":"<pre><code>import numpy as np\nimport pygrit\n\ndef create_random_intervals(chrom: str, chrom_length: int,\n                            n_intervals: int, min_length: int,\n                            max_length: int, seed: int = None) -&gt; pygrit.IntervalSet:\n    \"\"\"Create random non-overlapping intervals.\"\"\"\n    if seed is not None:\n        np.random.seed(seed)\n\n    # Generate random starts\n    starts = np.sort(np.random.randint(0, chrom_length - max_length, n_intervals))\n\n    # Generate random lengths\n    lengths = np.random.randint(min_length, max_length + 1, n_intervals)\n    ends = starts + lengths\n\n    # Ensure ends don't exceed chromosome length\n    ends = np.minimum(ends, chrom_length)\n\n    arr = np.column_stack([starts, ends])\n    intervals = pygrit.from_numpy(chrom, arr)\n\n    # Merge overlapping\n    return intervals.merge()\n\n# Create 1000 random intervals\nrandom_intervals = create_random_intervals(\n    \"chr1\", 100_000_000, 1000, 100, 1000, seed=42\n)\n</code></pre>"},{"location":"examples/numpy/#tiled-regions","title":"Tiled Regions","text":"<pre><code>import numpy as np\nimport pygrit\n\ndef tile_region(chrom: str, start: int, end: int, tile_size: int) -&gt; pygrit.IntervalSet:\n    \"\"\"Tile a region with non-overlapping intervals.\"\"\"\n    starts = np.arange(start, end, tile_size)\n    ends = np.minimum(starts + tile_size, end)\n\n    arr = np.column_stack([starts, ends])\n    return pygrit.from_numpy(chrom, arr)\n\n# Tile a 1Mb region with 10kb tiles\ntiles = tile_region(\"chr1\", 1_000_000, 2_000_000, 10_000)\nprint(f\"Created {len(tiles)} tiles\")\n</code></pre>"},{"location":"examples/numpy/#integration-with-pandas","title":"Integration with Pandas","text":""},{"location":"examples/numpy/#to-dataframe","title":"To DataFrame","text":"<pre><code>import numpy as np\nimport pandas as pd\nimport pygrit\n\nintervals = pygrit.read_bed(\"regions.bed\")\n\n# Convert to DataFrame\ndata = []\nfor iv in intervals.to_list():\n    data.append({\n        \"chrom\": iv.chrom,\n        \"start\": iv.start,\n        \"end\": iv.end,\n        \"length\": len(iv),\n    })\n\ndf = pd.DataFrame(data)\nprint(df.head())\n</code></pre>"},{"location":"examples/numpy/#from-dataframe","title":"From DataFrame","text":"<pre><code>import numpy as np\nimport pandas as pd\nimport pygrit\n\n# DataFrame with interval data\ndf = pd.DataFrame({\n    \"chrom\": [\"chr1\", \"chr1\", \"chr1\"],\n    \"start\": [100, 300, 500],\n    \"end\": [200, 400, 600],\n})\n\n# Group by chromosome and convert\nall_intervals = []\nfor chrom, group in df.groupby(\"chrom\"):\n    arr = group[[\"start\", \"end\"]].to_numpy()\n    intervals = pygrit.from_numpy(chrom, arr)\n    all_intervals.extend(intervals.to_list())\n\n# Create combined IntervalSet\ncombined = pygrit.IntervalSet.from_intervals(all_intervals)\n</code></pre>"},{"location":"examples/numpy/#performance-tips","title":"Performance Tips","text":""},{"location":"examples/numpy/#minimize-conversions","title":"Minimize Conversions","text":"<pre><code># Bad: Converting repeatedly\nfor _ in range(1000):\n    arr = intervals.to_numpy()  # Converts each time\n    # ... do something ...\n\n# Good: Convert once\narr = intervals.to_numpy()\nfor _ in range(1000):\n    # ... do something with arr ...\n</code></pre>"},{"location":"examples/numpy/#use-vectorized-operations","title":"Use Vectorized Operations","text":"<pre><code>import numpy as np\n\n# Bad: Python loop\nlengths = []\nfor iv in intervals.to_list():\n    lengths.append(len(iv))\n\n# Good: Vectorized NumPy\narr = intervals.to_numpy()\nlengths = arr[:, 1] - arr[:, 0]\n</code></pre>"},{"location":"examples/numpy/#pre-allocate-arrays","title":"Pre-allocate Arrays","text":"<pre><code>import numpy as np\n\n# When building intervals programmatically\nn = 10000\narr = np.empty((n, 2), dtype=np.int64)\n\nfor i in range(n):\n    arr[i, 0] = i * 1000\n    arr[i, 1] = i * 1000 + 500\n\nintervals = pygrit.from_numpy(\"chr1\", arr)\n</code></pre>"},{"location":"examples/workflows/","title":"Common Workflows","text":"<p>Real-world examples of using pygrit for genomic analysis.</p>"},{"location":"examples/workflows/#chip-seq-peak-analysis","title":"ChIP-seq Peak Analysis","text":""},{"location":"examples/workflows/#find-peaks-overlapping-promoters","title":"Find Peaks Overlapping Promoters","text":"<pre><code>import pygrit\n\n# Find peaks that overlap promoter regions\noverlapping_peaks = pygrit.intersect(\n    \"peaks.bed\",\n    \"promoters.bed\",\n    unique=True,  # Each peak once\n)\n\nprint(f\"Found {len(overlapping_peaks)} peaks in promoters\")\n</code></pre>"},{"location":"examples/workflows/#require-significant-overlap","title":"Require Significant Overlap","text":"<pre><code># Peaks must have at least 50% overlap with promoter\nsignificant_peaks = pygrit.intersect(\n    \"peaks.bed\",\n    \"promoters.bed\",\n    fraction=0.5,\n    unique=True,\n)\n</code></pre>"},{"location":"examples/workflows/#find-peaks-not-in-known-regions","title":"Find Peaks NOT in Known Regions","text":"<pre><code># Find novel peaks (not overlapping known enhancers)\nnovel_peaks = pygrit.intersect(\n    \"peaks.bed\",\n    \"known_enhancers.bed\",\n    no_overlap=True,\n)\n\nprint(f\"Found {len(novel_peaks)} novel peaks\")\n</code></pre>"},{"location":"examples/workflows/#rna-seq-analysis","title":"RNA-seq Analysis","text":""},{"location":"examples/workflows/#count-reads-per-gene","title":"Count Reads Per Gene","text":"<pre><code># Coverage of gene regions by aligned reads\npygrit.coverage(\n    \"genes.bed\",\n    \"aligned_reads.bed\",\n    mean=True,\n    output=\"gene_coverage.bed\"\n)\n</code></pre>"},{"location":"examples/workflows/#find-reads-in-exons-vs-introns","title":"Find Reads in Exons vs Introns","text":"<pre><code># Reads overlapping exons\nexon_reads = pygrit.intersect(\n    \"reads.bed\",\n    \"exons.bed\",\n    count=True,\n    output=\"exon_counts.bed\"\n)\n\n# Reads in introns (gene body minus exons)\nintron_regions = pygrit.subtract(\n    \"gene_bodies.bed\",\n    \"exons.bed\",\n    output=\"introns.bed\"\n)\n\npygrit.intersect(\n    \"reads.bed\",\n    \"introns.bed\",\n    count=True,\n    output=\"intron_counts.bed\"\n)\n</code></pre>"},{"location":"examples/workflows/#variant-analysis","title":"Variant Analysis","text":""},{"location":"examples/workflows/#filter-variants-by-region","title":"Filter Variants by Region","text":"<pre><code># Keep variants in coding regions\ncoding_variants = pygrit.intersect(\n    \"variants.bed\",\n    \"coding_regions.bed\",\n)\n\n# Remove variants in repetitive regions\nfiltered_variants = pygrit.subtract(\n    \"variants.bed\",\n    \"repeats.bed\",\n)\n</code></pre>"},{"location":"examples/workflows/#find-nearest-gene","title":"Find Nearest Gene","text":"<pre><code># For each variant, find the closest gene\npygrit.closest(\n    \"variants.bed\",\n    \"genes.bed\",\n    output=\"variant_nearest_gene.bed\"\n)\n</code></pre>"},{"location":"examples/workflows/#variants-in-promoter-windows","title":"Variants in Promoter Windows","text":"<pre><code># Variants within 2kb upstream of genes\npygrit.window(\n    \"gene_starts.bed\",\n    \"variants.bed\",\n    left=2000,\n    right=0,\n    output=\"promoter_variants.bed\"\n)\n</code></pre>"},{"location":"examples/workflows/#genome-annotation","title":"Genome Annotation","text":""},{"location":"examples/workflows/#merge-overlapping-annotations","title":"Merge Overlapping Annotations","text":"<pre><code># Merge overlapping gene annotations\nmerged_genes = pygrit.merge(\"all_gene_annotations.bed\")\n\n# Merge nearby features (within 1kb)\nmerged_features = pygrit.merge(\n    \"features.bed\",\n    distance=1000,\n)\n</code></pre>"},{"location":"examples/workflows/#create-non-overlapping-bins","title":"Create Non-Overlapping Bins","text":"<pre><code>import numpy as np\nimport pygrit\n\n# Create 10kb bins across a chromosome\nchrom_length = 250_000_000  # 250 Mb\nbin_size = 10_000\n\nstarts = np.arange(0, chrom_length, bin_size)\nends = np.minimum(starts + bin_size, chrom_length)\n\nbins = pygrit.from_numpy(\"chr1\", np.column_stack([starts, ends]))\n</code></pre>"},{"location":"examples/workflows/#subtract-known-regions","title":"Subtract Known Regions","text":"<pre><code># Find intergenic regions\nintergenic = pygrit.subtract(\n    \"chromosome.bed\",  # Whole chromosome\n    \"genes.bed\",\n    output=\"intergenic.bed\"\n)\n</code></pre>"},{"location":"examples/workflows/#pipeline-example","title":"Pipeline Example","text":""},{"location":"examples/workflows/#complete-analysis-pipeline","title":"Complete Analysis Pipeline","text":"<pre><code>import pygrit\nfrom pathlib import Path\n\ndef analyze_chip_peaks(\n    peaks_file: str,\n    genes_file: str,\n    enhancers_file: str,\n    output_dir: str,\n):\n    \"\"\"Comprehensive ChIP-seq peak analysis.\"\"\"\n\n    out = Path(output_dir)\n    out.mkdir(exist_ok=True)\n\n    # 1. Merge nearby peaks\n    pygrit.merge(\n        peaks_file,\n        distance=500,\n        output=str(out / \"merged_peaks.bed\")\n    )\n\n    # 2. Find promoter peaks\n    pygrit.intersect(\n        str(out / \"merged_peaks.bed\"),\n        genes_file,\n        fraction=0.5,\n        unique=True,\n        output=str(out / \"promoter_peaks.bed\")\n    )\n\n    # 3. Find enhancer peaks\n    pygrit.intersect(\n        str(out / \"merged_peaks.bed\"),\n        enhancers_file,\n        unique=True,\n        output=str(out / \"enhancer_peaks.bed\")\n    )\n\n    # 4. Find novel peaks (not promoter or enhancer)\n    pygrit.intersect(\n        str(out / \"merged_peaks.bed\"),\n        genes_file,\n        no_overlap=True,\n        output=str(out / \"temp_not_promoter.bed\")\n    )\n\n    pygrit.intersect(\n        str(out / \"temp_not_promoter.bed\"),\n        enhancers_file,\n        no_overlap=True,\n        output=str(out / \"novel_peaks.bed\")\n    )\n\n    # 5. Count results\n    promoter_peaks = pygrit.read_bed(str(out / \"promoter_peaks.bed\"))\n    enhancer_peaks = pygrit.read_bed(str(out / \"enhancer_peaks.bed\"))\n    novel_peaks = pygrit.read_bed(str(out / \"novel_peaks.bed\"))\n\n    return {\n        \"promoter\": len(promoter_peaks),\n        \"enhancer\": len(enhancer_peaks),\n        \"novel\": len(novel_peaks),\n    }\n\n# Run analysis\nresults = analyze_chip_peaks(\n    \"chip_peaks.bed\",\n    \"gene_promoters.bed\",\n    \"enhancer_regions.bed\",\n    \"analysis_output\",\n)\n\nprint(f\"Promoter peaks: {results['promoter']}\")\nprint(f\"Enhancer peaks: {results['enhancer']}\")\nprint(f\"Novel peaks: {results['novel']}\")\n</code></pre>"},{"location":"examples/workflows/#parallel-processing","title":"Parallel Processing","text":""},{"location":"examples/workflows/#process-multiple-chromosomes","title":"Process Multiple Chromosomes","text":"<pre><code>from concurrent.futures import ThreadPoolExecutor\nimport pygrit\n\nchromosomes = [f\"chr{i}\" for i in range(1, 23)] + [\"chrX\", \"chrY\"]\n\ndef process_chromosome(chrom):\n    \"\"\"Process a single chromosome.\"\"\"\n    pygrit.intersect(\n        f\"peaks_{chrom}.bed\",\n        f\"genes_{chrom}.bed\",\n        output=f\"results_{chrom}.bed\"\n    )\n    return chrom\n\n# Process in parallel (pygrit releases GIL)\nwith ThreadPoolExecutor(max_workers=8) as executor:\n    completed = list(executor.map(process_chromosome, chromosomes))\n\nprint(f\"Processed {len(completed)} chromosomes\")\n</code></pre>"},{"location":"examples/workflows/#batch-processing","title":"Batch Processing","text":"<pre><code>from pathlib import Path\n\ndef batch_merge(input_dir: str, output_dir: str, distance: int = 100):\n    \"\"\"Merge all BED files in a directory.\"\"\"\n\n    input_path = Path(input_dir)\n    output_path = Path(output_dir)\n    output_path.mkdir(exist_ok=True)\n\n    for bed_file in input_path.glob(\"*.bed\"):\n        output_file = output_path / f\"merged_{bed_file.name}\"\n        pygrit.merge(\n            str(bed_file),\n            distance=distance,\n            output=str(output_file)\n        )\n        print(f\"Merged: {bed_file.name}\")\n\nbatch_merge(\"raw_peaks\", \"merged_peaks\", distance=500)\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9 or later</li> <li>NumPy 1.20 or later</li> </ul>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":"<pre><code>pip install grit-genomics\n</code></pre> <p>The package is imported as <code>pygrit</code>:</p> <pre><code>import pygrit\nprint(pygrit.__version__)\n</code></pre>"},{"location":"getting-started/installation/#install-from-source","title":"Install from Source","text":"<p>Building from source requires Rust and maturin.</p>"},{"location":"getting-started/installation/#1-install-rust","title":"1. Install Rust","text":"<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nsource ~/.cargo/env\n</code></pre>"},{"location":"getting-started/installation/#2-clone-the-repository","title":"2. Clone the Repository","text":"<pre><code>git clone https://github.com/manish59/grit.git\ncd grit/py-pygrit\n</code></pre>"},{"location":"getting-started/installation/#3-create-a-virtual-environment","title":"3. Create a Virtual Environment","text":"<pre><code>python -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n</code></pre>"},{"location":"getting-started/installation/#4-install-maturin-and-build","title":"4. Install maturin and Build","text":"<pre><code>pip install maturin\nmaturin develop --release\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<pre><code>import pygrit\n\n# Check version\nprint(pygrit.__version__)\n\n# Test basic functionality\niv = pygrit.Interval(\"chr1\", 100, 200)\nprint(iv)  # chr1   100 200\n</code></pre>"},{"location":"getting-started/installation/#platform-support","title":"Platform Support","text":"Platform Architecture Pre-built Wheel From Source macOS ARM64 (Apple Silicon) Yes Yes macOS x86_64 No Yes Linux x86_64 No Yes Linux ARM64 No Yes Windows x86_64 No Untested <p>For platforms without pre-built wheels, pip will attempt to build from source. This requires a Rust toolchain to be installed.</p>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#importerror-no-module-named-pygrit","title":"ImportError: No module named 'pygrit'","text":"<p>Ensure you have installed grit-genomics:</p> <pre><code>pip install grit-genomics\n</code></pre>"},{"location":"getting-started/installation/#build-errors-source-install","title":"Build Errors (Source Install)","text":"<p>Make sure you have the latest Rust toolchain:</p> <pre><code>rustup update\n</code></pre>"},{"location":"getting-started/installation/#numpy-version-issues","title":"NumPy Version Issues","text":"<pre><code>pip install --upgrade numpy\npip install --force-reinstall grit-genomics\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide will get you up and running with pygrit.</p>"},{"location":"getting-started/quickstart/#installation","title":"Installation","text":"<pre><code>pip install grit-genomics\n</code></pre>"},{"location":"getting-started/quickstart/#basic-concepts","title":"Basic Concepts","text":"<p>pygrit works with genomic intervals - regions on chromosomes defined by:</p> <ul> <li>Chromosome: The chromosome name (e.g., \"chr1\", \"chrX\")</li> <li>Start: The 0-based start position (inclusive)</li> <li>End: The end position (exclusive)</li> </ul> <p>This follows the BED format convention (0-based, half-open intervals).</p>"},{"location":"getting-started/quickstart/#your-first-operations","title":"Your First Operations","text":""},{"location":"getting-started/quickstart/#creating-intervals","title":"Creating Intervals","text":"<pre><code>import pygrit\n\n# Create a single interval\ninterval = pygrit.Interval(\"chr1\", 100, 200)\nprint(f\"Interval: {interval}\")        # chr1    100    200\nprint(f\"Length: {len(interval)} bp\")  # Length: 100 bp\n</code></pre>"},{"location":"getting-started/quickstart/#reading-bed-files","title":"Reading BED Files","text":"<pre><code># Read intervals from a BED file\nintervals = pygrit.read_bed(\"regions.bed\")\nprint(f\"Loaded {len(intervals)} intervals\")\n\n# Access individual intervals\nfirst = intervals[0]\nprint(f\"First interval: {first.chrom}:{first.start}-{first.end}\")\n</code></pre>"},{"location":"getting-started/quickstart/#finding-overlaps","title":"Finding Overlaps","text":"<pre><code># Find overlapping intervals between two files\noverlaps = pygrit.intersect(\"features.bed\", \"regions.bed\")\nprint(f\"Found {len(overlaps)} overlapping intervals\")\n\n# Write results to a file\npygrit.intersect(\n    \"features.bed\",\n    \"regions.bed\",\n    output=\"overlaps.bed\"\n)\n</code></pre>"},{"location":"getting-started/quickstart/#merging-intervals","title":"Merging Intervals","text":"<pre><code># Merge overlapping intervals\nmerged = pygrit.merge(\"input.bed\")\n\n# Merge intervals within 1000bp of each other\nmerged = pygrit.merge(\"input.bed\", distance=1000)\n</code></pre>"},{"location":"getting-started/quickstart/#sorting-a-bed-file","title":"Sorting a BED File","text":"<pre><code># Sort an unsorted BED file\npygrit.sort(\"unsorted.bed\", output=\"sorted.bed\")\n</code></pre>"},{"location":"getting-started/quickstart/#input-requirements","title":"Input Requirements","text":"<p>Important: Most functions require sorted BED files (sorted by chromosome, then by start position).</p> <p>Sort your files first:</p> <pre><code># Using grit CLI\ngrit sort -i unsorted.bed &gt; sorted.bed\n\n# Using Unix sort\nsort -k1,1 -k2,2n unsorted.bed &gt; sorted.bed\n</code></pre> <p>Or in Python:</p> <pre><code>pygrit.sort(\"unsorted.bed\", output=\"sorted.bed\")\n</code></pre>"},{"location":"getting-started/quickstart/#file-based-vs-in-memory-operations","title":"File-Based vs In-Memory Operations","text":""},{"location":"getting-started/quickstart/#file-based-operations","title":"File-Based Operations","text":"<p>Process files directly - suitable for larger files:</p> <pre><code># Returns list of Interval objects\noverlaps = pygrit.intersect(\"a.bed\", \"b.bed\")\n\n# Or write directly to file\npygrit.intersect(\"a.bed\", \"b.bed\", output=\"result.bed\")\n</code></pre>"},{"location":"getting-started/quickstart/#in-memory-operations","title":"In-Memory Operations","text":"<p>Load intervals into memory for manipulation:</p> <pre><code># Load into memory\nintervals = pygrit.read_bed(\"regions.bed\")\nmerged = intervals.merge(distance=100)\n\n# Convert to list for iteration\nfor iv in merged.to_list():\n    print(iv)\n</code></pre>"},{"location":"getting-started/quickstart/#working-with-results","title":"Working with Results","text":""},{"location":"getting-started/quickstart/#as-python-lists","title":"As Python Lists","text":"<pre><code>results = pygrit.intersect(\"a.bed\", \"b.bed\")\n\nfor interval in results:\n    print(f\"{interval.chrom}:{interval.start}-{interval.end}\")\n</code></pre>"},{"location":"getting-started/quickstart/#as-numpy-arrays","title":"As NumPy Arrays","text":"<pre><code>import numpy as np\n\nintervals = pygrit.read_bed(\"regions.bed\")\narr = intervals.to_numpy()  # Shape: (n, 2) with [start, end]\n\n# Calculate interval lengths\nlengths = arr[:, 1] - arr[:, 0]\nprint(f\"Mean length: {np.mean(lengths):.1f} bp\")\n</code></pre>"},{"location":"getting-started/quickstart/#common-options","title":"Common Options","text":"<p>Most file-based operations support these options:</p> Option Description <code>output</code> Write to file instead of returning list <code>fraction</code> Minimum overlap fraction (0.0-1.0) <code>reciprocal</code> Require reciprocal overlap fraction"},{"location":"getting-started/quickstart/#example-reciprocal-overlap","title":"Example: Reciprocal Overlap","text":"<pre><code># Require at least 50% overlap in both directions\npygrit.intersect(\n    \"a.bed\",\n    \"b.bed\",\n    fraction=0.5,\n    reciprocal=True,\n    output=\"significant_overlaps.bed\"\n)\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>File Operations Guide - Detailed guide on all commands</li> <li>In-Memory Guide - Working with intervals in memory</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"guide/file-operations/","title":"File Operations","text":"<p>File-based operations are the core strength of pygrit. They use streaming algorithms that process data with O(k) memory complexity, where k is the maximum number of overlapping intervals at any genomic position.</p>"},{"location":"guide/file-operations/#requirements","title":"Requirements","text":"<p>Sorted Input Required</p> <p>All file-based operations require sorted BED files. Sort your files by chromosome and start position: <pre><code>sort -k1,1 -k2,2n input.bed &gt; sorted.bed\n</code></pre></p>"},{"location":"guide/file-operations/#intersect","title":"intersect","text":"<p>Find overlapping intervals between two files.</p>"},{"location":"guide/file-operations/#basic-usage","title":"Basic Usage","text":"<pre><code>import pygrit\n\n# Return as list\noverlaps = pygrit.intersect(\"features.bed\", \"regions.bed\")\n\n# Write to file (more memory efficient)\npygrit.intersect(\"features.bed\", \"regions.bed\", output=\"overlaps.bed\")\n</code></pre>"},{"location":"guide/file-operations/#options","title":"Options","text":""},{"location":"guide/file-operations/#write-original-records","title":"Write Original Records","text":"<pre><code># Include original A record (-wa equivalent)\npygrit.intersect(\"a.bed\", \"b.bed\", write_a=True, output=\"out.bed\")\n\n# Include both A and B records (-wa -wb equivalent)\npygrit.intersect(\"a.bed\", \"b.bed\", write_a=True, write_b=True, output=\"out.bed\")\n</code></pre>"},{"location":"guide/file-operations/#overlap-fraction","title":"Overlap Fraction","text":"<pre><code># Require at least 50% of A to be overlapped\npygrit.intersect(\"a.bed\", \"b.bed\", fraction=0.5, output=\"out.bed\")\n\n# Require reciprocal 50% overlap\npygrit.intersect(\"a.bed\", \"b.bed\", fraction=0.5, reciprocal=True, output=\"out.bed\")\n</code></pre>"},{"location":"guide/file-operations/#unique-and-count","title":"Unique and Count","text":"<pre><code># Report each A interval only once (-u equivalent)\npygrit.intersect(\"a.bed\", \"b.bed\", unique=True, output=\"out.bed\")\n\n# Report overlap count for each A (-c equivalent)\npygrit.intersect(\"a.bed\", \"b.bed\", count=True, output=\"out.bed\")\n</code></pre>"},{"location":"guide/file-operations/#non-overlapping","title":"Non-Overlapping","text":"<pre><code># Report A intervals that DON'T overlap B (-v equivalent)\nnon_overlapping = pygrit.intersect(\"a.bed\", \"b.bed\", no_overlap=True)\n</code></pre>"},{"location":"guide/file-operations/#merge","title":"merge","text":"<p>Merge overlapping or nearby intervals.</p>"},{"location":"guide/file-operations/#basic-usage_1","title":"Basic Usage","text":"<pre><code># Merge overlapping intervals\nmerged = pygrit.merge(\"input.bed\")\n\n# Write to file\npygrit.merge(\"input.bed\", output=\"merged.bed\")\n</code></pre>"},{"location":"guide/file-operations/#options_1","title":"Options","text":""},{"location":"guide/file-operations/#distance","title":"Distance","text":"<pre><code># Merge intervals within 1000bp of each other\npygrit.merge(\"input.bed\", distance=1000, output=\"merged.bed\")\n</code></pre>"},{"location":"guide/file-operations/#strand-specific","title":"Strand-Specific","text":"<pre><code># Merge only intervals on the same strand\npygrit.merge(\"input.bed\", strand=True, output=\"merged.bed\")\n</code></pre>"},{"location":"guide/file-operations/#subtract","title":"subtract","text":"<p>Remove portions of A that overlap with B.</p>"},{"location":"guide/file-operations/#basic-usage_2","title":"Basic Usage","text":"<pre><code># Subtract B from A\nresult = pygrit.subtract(\"features.bed\", \"exclude.bed\")\n</code></pre>"},{"location":"guide/file-operations/#options_2","title":"Options","text":""},{"location":"guide/file-operations/#remove-entire-interval","title":"Remove Entire Interval","text":"<pre><code># Remove entire A interval if any overlap with B (-A equivalent)\npygrit.subtract(\"a.bed\", \"b.bed\", remove_entire=True, output=\"out.bed\")\n</code></pre>"},{"location":"guide/file-operations/#fraction-requirements","title":"Fraction Requirements","text":"<pre><code># Only subtract if overlap &gt;= 50% of A\npygrit.subtract(\"a.bed\", \"b.bed\", fraction=0.5, output=\"out.bed\")\n</code></pre>"},{"location":"guide/file-operations/#coverage","title":"coverage","text":"<p>Calculate coverage of A by B.</p>"},{"location":"guide/file-operations/#basic-usage_3","title":"Basic Usage","text":"<pre><code># Get coverage information\nresult = pygrit.coverage(\"regions.bed\", \"reads.bed\")\n</code></pre>"},{"location":"guide/file-operations/#options_3","title":"Options","text":""},{"location":"guide/file-operations/#histogram","title":"Histogram","text":"<pre><code># Report depth histogram\nresult = pygrit.coverage(\"regions.bed\", \"reads.bed\", histogram=True)\n</code></pre>"},{"location":"guide/file-operations/#mean-depth","title":"Mean Depth","text":"<pre><code># Report mean depth per region\nresult = pygrit.coverage(\"regions.bed\", \"reads.bed\", mean=True)\n</code></pre>"},{"location":"guide/file-operations/#closest","title":"closest","text":"<p>Find the closest B interval for each A interval.</p>"},{"location":"guide/file-operations/#basic-usage_4","title":"Basic Usage","text":"<pre><code>result = pygrit.closest(\"queries.bed\", \"targets.bed\")\n</code></pre>"},{"location":"guide/file-operations/#options_4","title":"Options","text":""},{"location":"guide/file-operations/#direction-control","title":"Direction Control","text":"<pre><code># Ignore overlapping intervals\nresult = pygrit.closest(\"a.bed\", \"b.bed\", ignore_overlaps=True)\n\n# Only find downstream (3') intervals\nresult = pygrit.closest(\"a.bed\", \"b.bed\", ignore_upstream=True)\n\n# Only find upstream (5') intervals\nresult = pygrit.closest(\"a.bed\", \"b.bed\", ignore_downstream=True)\n</code></pre>"},{"location":"guide/file-operations/#window","title":"window","text":"<p>Find B intervals within a window distance of A intervals.</p>"},{"location":"guide/file-operations/#basic-usage_5","title":"Basic Usage","text":"<pre><code># Find B intervals within 1000bp of A intervals\nresult = pygrit.window(\"a.bed\", \"b.bed\", window=1000)\n</code></pre>"},{"location":"guide/file-operations/#options_5","title":"Options","text":""},{"location":"guide/file-operations/#asymmetric-window","title":"Asymmetric Window","text":"<pre><code># Different left and right windows\nresult = pygrit.window(\"a.bed\", \"b.bed\", left=5000, right=1000)\n</code></pre>"},{"location":"guide/file-operations/#count-mode","title":"Count Mode","text":"<pre><code># Report count of B intervals in window\nresult = pygrit.window(\"a.bed\", \"b.bed\", window=1000, count=True)\n</code></pre>"},{"location":"guide/file-operations/#output-modes","title":"Output Modes","text":""},{"location":"guide/file-operations/#return-as-list","title":"Return as List","text":"<p>When <code>output</code> is not specified, operations return a list of <code>Interval</code> objects:</p> <pre><code>results = pygrit.intersect(\"a.bed\", \"b.bed\")\nfor iv in results:\n    print(f\"{iv.chrom}:{iv.start}-{iv.end}\")\n</code></pre>"},{"location":"guide/file-operations/#write-to-file","title":"Write to File","text":"<p>When <code>output</code> is specified, results are written directly to the file:</p> <pre><code>pygrit.intersect(\"a.bed\", \"b.bed\", output=\"results.bed\")\n# Returns None, but results.bed contains the output\n</code></pre> <p>Memory Efficiency</p> <p>Use <code>output=</code> for large result sets. Writing directly to a file avoids loading all results into memory.</p>"},{"location":"guide/file-operations/#error-handling","title":"Error Handling","text":"<pre><code>try:\n    results = pygrit.intersect(\"a.bed\", \"missing.bed\")\nexcept IOError as e:\n    print(f\"File error: {e}\")\nexcept RuntimeError as e:\n    print(f\"Processing error: {e}\")  # e.g., unsorted input\nexcept ValueError as e:\n    print(f\"Invalid parameter: {e}\")\n</code></pre>"},{"location":"guide/in-memory/","title":"In-Memory Operations","text":"<p>For smaller datasets or when you need programmatic access to interval data, pygrit provides in-memory classes: <code>Interval</code> and <code>IntervalSet</code>.</p>"},{"location":"guide/in-memory/#interval-class","title":"Interval Class","text":"<p>The <code>Interval</code> class represents a single genomic interval.</p>"},{"location":"guide/in-memory/#creating-intervals","title":"Creating Intervals","text":"<pre><code>import pygrit\n\n# Create an interval\niv = pygrit.Interval(\"chr1\", 100, 200)\n\n# Access properties\nprint(iv.chrom)  # \"chr1\"\nprint(iv.start)  # 100\nprint(iv.end)    # 200\nprint(len(iv))   # 100 (length in base pairs)\n</code></pre>"},{"location":"guide/in-memory/#interval-methods","title":"Interval Methods","text":""},{"location":"guide/in-memory/#overlap-detection","title":"Overlap Detection","text":"<pre><code>iv1 = pygrit.Interval(\"chr1\", 100, 200)\niv2 = pygrit.Interval(\"chr1\", 150, 250)\niv3 = pygrit.Interval(\"chr1\", 300, 400)\n\n# Check if intervals overlap\niv1.overlaps(iv2)  # True\niv1.overlaps(iv3)  # False\n\n# Get overlap length\niv1.overlap_length(iv2)  # 50\niv1.overlap_length(iv3)  # 0\n</code></pre>"},{"location":"guide/in-memory/#distance-calculation","title":"Distance Calculation","text":"<pre><code>iv1 = pygrit.Interval(\"chr1\", 100, 200)\niv2 = pygrit.Interval(\"chr1\", 300, 400)\niv3 = pygrit.Interval(\"chr2\", 100, 200)\n\n# Distance between intervals\niv1.distance_to(iv2)  # 100 (gap between them)\niv1.distance_to(iv3)  # None (different chromosomes)\n\n# Overlapping intervals have distance 0\niv1.distance_to(pygrit.Interval(\"chr1\", 150, 250))  # 0\n</code></pre>"},{"location":"guide/in-memory/#conversion-methods","title":"Conversion Methods","text":"<pre><code>iv = pygrit.Interval(\"chr1\", 100, 200)\n\n# To tuple\niv.to_tuple()  # (\"chr1\", 100, 200)\n\n# String representations\nstr(iv)   # \"chr1\\t100\\t200\" (BED format)\nrepr(iv)  # \"Interval('chr1', 100, 200)\"\n</code></pre>"},{"location":"guide/in-memory/#comparison-and-hashing","title":"Comparison and Hashing","text":"<p>Intervals are hashable and can be used in sets and dictionaries:</p> <pre><code>iv1 = pygrit.Interval(\"chr1\", 100, 200)\niv2 = pygrit.Interval(\"chr1\", 100, 200)\niv3 = pygrit.Interval(\"chr1\", 150, 250)\n\n# Equality\niv1 == iv2  # True\niv1 == iv3  # False\n\n# Use in sets\nunique_intervals = {iv1, iv2, iv3}\nlen(unique_intervals)  # 2\n\n# Use as dict keys\ncoverage = {iv1: 10.5, iv3: 8.2}\n</code></pre>"},{"location":"guide/in-memory/#intervalset-class","title":"IntervalSet Class","text":"<p>The <code>IntervalSet</code> class represents a collection of intervals with bulk operations.</p>"},{"location":"guide/in-memory/#creating-intervalsets","title":"Creating IntervalSets","text":"<pre><code># Empty set\nintervals = pygrit.IntervalSet()\n\n# From list of intervals\nintervals = pygrit.IntervalSet.from_intervals([\n    pygrit.Interval(\"chr1\", 100, 200),\n    pygrit.Interval(\"chr1\", 150, 250),\n    pygrit.Interval(\"chr1\", 300, 400),\n])\n\n# From BED file\nintervals = pygrit.read_bed(\"regions.bed\")\n\n# From BED string\ncontent = \"chr1\\t100\\t200\\nchr1\\t300\\t400\\n\"\nintervals = pygrit.parse_bed(content)\n</code></pre>"},{"location":"guide/in-memory/#basic-operations","title":"Basic Operations","text":"<pre><code>intervals = pygrit.read_bed(\"regions.bed\")\n\n# Length\nlen(intervals)  # Number of intervals\n\n# Indexing\nfirst = intervals[0]\nlast = intervals[-1]\n\n# Iteration\nfor iv in intervals.to_list():\n    print(iv)\n</code></pre>"},{"location":"guide/in-memory/#adding-intervals","title":"Adding Intervals","text":"<pre><code>intervals = pygrit.IntervalSet()\nintervals.add(pygrit.Interval(\"chr1\", 100, 200))\nintervals.add(pygrit.Interval(\"chr1\", 300, 400))\n</code></pre>"},{"location":"guide/in-memory/#merge","title":"Merge","text":"<p>Merge overlapping or nearby intervals:</p> <pre><code>intervals = pygrit.IntervalSet.from_intervals([\n    pygrit.Interval(\"chr1\", 100, 200),\n    pygrit.Interval(\"chr1\", 150, 250),  # Overlaps previous\n    pygrit.Interval(\"chr1\", 500, 600),  # Separate\n])\n\n# Merge overlapping\nmerged = intervals.merge()\n# Result: [chr1:100-250, chr1:500-600]\n\n# Merge with distance tolerance\nmerged = intervals.merge(distance=300)\n# Result: [chr1:100-600] (all within 300bp)\n</code></pre>"},{"location":"guide/in-memory/#intersect","title":"Intersect","text":"<p>Find intervals that overlap with another set:</p> <pre><code>set_a = pygrit.IntervalSet.from_intervals([\n    pygrit.Interval(\"chr1\", 100, 200),\n    pygrit.Interval(\"chr1\", 300, 400),\n])\n\nset_b = pygrit.IntervalSet.from_intervals([\n    pygrit.Interval(\"chr1\", 150, 350),\n])\n\n# Find overlapping intervals from A\noverlapping = set_a.intersect(set_b)\n\n# With fraction requirement\noverlapping = set_a.intersect(set_b, fraction=0.5)\n\n# Reciprocal fraction\noverlapping = set_a.intersect(set_b, fraction=0.5, reciprocal=True)\n</code></pre>"},{"location":"guide/in-memory/#non-overlapping","title":"Non-Overlapping","text":"<p>Find intervals that don't overlap with another set:</p> <pre><code>non_overlapping = set_a.non_overlapping(set_b)\n</code></pre>"},{"location":"guide/in-memory/#sort","title":"Sort","text":"<p>Sort intervals in place by chromosome and start position:</p> <pre><code>intervals = pygrit.IntervalSet.from_intervals([\n    pygrit.Interval(\"chr2\", 100, 200),\n    pygrit.Interval(\"chr1\", 300, 400),\n    pygrit.Interval(\"chr1\", 100, 200),\n])\n\nintervals.sort()\n# Now: [chr1:100-200, chr1:300-400, chr2:100-200]\n</code></pre>"},{"location":"guide/in-memory/#numpy-integration","title":"NumPy Integration","text":""},{"location":"guide/in-memory/#from-numpy-to-intervals","title":"From NumPy to Intervals","text":"<pre><code>import numpy as np\n\n# Create intervals from NumPy array\narr = np.array([\n    [100, 200],\n    [300, 400],\n    [500, 600],\n], dtype=np.int64)\n\nintervals = pygrit.from_numpy(\"chr1\", arr)\n</code></pre>"},{"location":"guide/in-memory/#from-intervals-to-numpy","title":"From Intervals to NumPy","text":"<pre><code>intervals = pygrit.read_bed(\"regions.bed\")\n\n# Convert to NumPy array (shape: n x 2)\narr = intervals.to_numpy()\n\n# Calculate statistics\nlengths = arr[:, 1] - arr[:, 0]\nprint(f\"Mean length: {np.mean(lengths):.1f}\")\nprint(f\"Total coverage: {np.sum(lengths)}\")\n</code></pre>"},{"location":"guide/in-memory/#when-to-use-in-memory-vs-file-based","title":"When to Use In-Memory vs File-Based","text":"Use Case Recommended Approach Large files (&gt;1M intervals) File-based operations Small datasets (&lt;100K intervals) Either works well Complex manipulation In-memory (IntervalSet) Pipeline processing File-based (streaming) Interactive analysis In-memory (IntervalSet) NumPy integration In-memory with to_numpy()"},{"location":"guide/performance/","title":"Performance Tips","text":"<p>This guide covers best practices for using pygrit effectively.</p>"},{"location":"guide/performance/#best-practices","title":"Best Practices","text":""},{"location":"guide/performance/#1-sort-your-input-files","title":"1. Sort Your Input Files","text":"<p>Most pygrit functions require sorted BED files (sorted by chromosome, then by start position).</p> <pre><code># Using grit CLI\ngrit sort -i unsorted.bed &gt; sorted.bed\n\n# Using Unix sort\nsort -k1,1 -k2,2n input.bed &gt; sorted.bed\n</code></pre> <p>Or in Python:</p> <pre><code>pygrit.sort(\"unsorted.bed\", output=\"sorted.bed\")\n</code></pre>"},{"location":"guide/performance/#2-use-output-files-for-large-results","title":"2. Use Output Files for Large Results","text":"<p>When processing large files, write directly to output files instead of returning results to Python:</p> <pre><code># Recommended for large files: Write directly to file\npygrit.intersect(\"a.bed\", \"b.bed\", output=\"result.bed\")\n\n# For small results: Return to Python\nsmall_results = pygrit.intersect(\"small_a.bed\", \"small_b.bed\")\n</code></pre>"},{"location":"guide/performance/#3-apply-filters-early","title":"3. Apply Filters Early","text":"<p>Use filters during operations to reduce output size:</p> <pre><code># Filter during intersection\npygrit.intersect(\"a.bed\", \"b.bed\", fraction=0.5, output=\"result.bed\")\n\n# Use unique mode when you only need to know which intervals overlap\npygrit.intersect(\"a.bed\", \"b.bed\", unique=True, output=\"result.bed\")\n</code></pre>"},{"location":"guide/performance/#4-use-the-right-tool-for-the-job","title":"4. Use the Right Tool for the Job","text":"Data Size Recommendation Small (&lt;100K intervals) In-memory operations work well Medium (100K - 10M) File-based operations Large (&gt;10M) File-based with output files"},{"location":"guide/performance/#profiling-your-workload","title":"Profiling Your Workload","text":""},{"location":"guide/performance/#memory-profiling","title":"Memory Profiling","text":"<pre><code>import tracemalloc\n\ntracemalloc.start()\npygrit.intersect(\"a.bed\", \"b.bed\", output=\"result.bed\")\ncurrent, peak = tracemalloc.get_traced_memory()\ntracemalloc.stop()\n\nprint(f\"Peak memory: {peak / 1024 / 1024:.1f} MB\")\n</code></pre>"},{"location":"guide/performance/#timing","title":"Timing","text":"<pre><code>import time\n\nstart = time.perf_counter()\npygrit.intersect(\"a.bed\", \"b.bed\", output=\"result.bed\")\nelapsed = time.perf_counter() - start\n\nprint(f\"Elapsed: {elapsed:.3f}s\")\n</code></pre>"},{"location":"guide/performance/#common-issues","title":"Common Issues","text":""},{"location":"guide/performance/#unsorted-input","title":"Unsorted Input","text":"<p>Symptom: RuntimeError about unsorted input</p> <p>Solution: Sort your files first:</p> <pre><code>pygrit.sort(\"unsorted.bed\", output=\"sorted.bed\")\n</code></pre>"},{"location":"guide/performance/#missing-genome-file","title":"Missing Genome File","text":"<p>Symptom: Error about missing genome file</p> <p>Solution: Create a genome file (tab-separated chromosome name and size):</p> <pre><code>chr1    248956422\nchr2    242193529\nchr3    198295559\n</code></pre> <p>Functions that require genome files: <code>slop</code>, <code>complement</code>, <code>genomecov</code></p>"},{"location":"guide/performance/#high-memory-usage","title":"High Memory Usage","text":"<p>Symptom: High memory usage when processing large files</p> <p>Solutions:</p> <ol> <li>Use <code>output=</code> parameter to write directly to files</li> <li>Process chromosomes separately</li> <li>Use smaller input files</li> </ol>"},{"location":"guide/performance/#benchmark-your-own-data","title":"Benchmark Your Own Data","text":"<p>Performance varies significantly based on:</p> <ul> <li>Data size and distribution</li> <li>Overlap density</li> <li>Hardware (CPU, disk speed, RAM)</li> </ul> <p>We recommend benchmarking on your own datasets:</p> <pre><code>import time\nimport tempfile\n\ndef benchmark(func, *args, **kwargs):\n    start = time.perf_counter()\n    func(*args, **kwargs)\n    return time.perf_counter() - start\n\nwith tempfile.NamedTemporaryFile(suffix=\".bed\") as tmp:\n    elapsed = benchmark(\n        pygrit.intersect,\n        \"a.bed\", \"b.bed\",\n        output=tmp.name\n    )\n    print(f\"intersect: {elapsed:.3f}s\")\n</code></pre>"}]}